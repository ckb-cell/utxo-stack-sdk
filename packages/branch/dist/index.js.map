{"version":3,"sources":["../src/rpc/index.ts","../src/utils/index.ts","../src/utils/ecpair.ts","../src/utils/exceptions/ErrorCode.ts","../src/utils/exceptions/common.ts","../src/utils/exceptions/string.ts","../src/utils/exceptions/address.ts","../src/utils/exceptions/blake2b.ts","../src/utils/exceptions/privateKey.ts","../src/utils/exceptions/transaction.ts","../src/utils/validators.ts","../src/utils/convertors/index.ts","../src/utils/systemScripts.ts","../src/utils/address/index.ts","../src/utils/crypto/index.ts","../src/utils/crypto/blake2b.ts","../src/utils/const.ts","../src/utils/crypto/blake160.ts","../src/utils/serialization/basic.ts","../src/utils/serialization/script.ts","../src/utils/serialization/transaction.ts","../src/utils/occupiedCapacity.ts","../src/utils/epochs.ts","../src/utils/sizes.ts","../src/utils/reconcilers/extraInputs.ts","../src/utils/calculateTransactionFee.ts","../src/rpc/exceptions/formatter.ts","../src/rpc/exceptions/rpc.ts","../src/rpc/exceptions/batch.ts","../src/rpc/paramsFormatter.ts","../src/rpc/resultFormatter.ts","../src/rpc/base/chain.ts","../src/rpc/base/experimental.ts","../src/rpc/base/net.ts","../src/rpc/base/pool.ts","../src/rpc/base/stats.ts","../src/rpc/base/index.ts","../src/rpc/method.ts","../src/core/generateRawTransaction.ts","../src/core/loadCellsFromIndexer.ts","../src/core/multisig.ts","../src/core/signWitnessGroup.ts","../src/core/groupScripts.ts","../src/core/signWitnesses.ts","../src/core/branch.ts","../src/types/blockchain.ts"],"names":["axios","JSBI","ErrorCode","AddressPrefix","AddressType","Bech32Type","HashType","_node","SignStatus","v","toHex","CKBComponents","TransactionStatus","CellStatus","CapacityUnit"],"mappings":";;;;;;;;;;;;;;AAAA,OAAOA,YAAW;;;ACAlB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,cAAAC;AAAA,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OAAOA,WAAU;;;ACAjB,SAAS,MAAM,UAAU;;;ACAlB,IAAK,YAAL,kBAAKC,eAAL;AACL,EAAAA,sBAAA,sBAAmB,OAAnB;AACA,EAAAA,sBAAA;AACA,EAAAA,sBAAA;AACA,EAAAA,sBAAA;AACA,EAAAA,sBAAA;AALU,SAAAA;AAAA,GAAA;;;ACEL,IAAM,6BAAN,cAAyC,MAAM;AAAA,EAGpD,YAAY,MAAc;AACxB,UAAM,GAAG,IAAI,cAAc;AAH7B;AAAA,EAIA;AACF;AAEO,IAAM,uBAAN,cAAmC,MAAM;AAAA,EAG9C,cAAc;AACZ,UAAM,0BAA0B;AAHlC;AAAA,EAIA;AACF;;;ACdO,IAAM,qBAAN,cAAiC,MAAM;AAAA,EAG5C,YAAY,KAAa;AACvB,UAAM,GAAG,GAAG,2BAA2B;AAHzC;AAAA,EAIA;AACF;AAEO,IAAM,8BAAN,cAA0C,MAAM;AAAA,EAGrD,YAAY,KAAa;AACvB,UAAM,cAAc,GAAG,uBAAuB;AAHhD;AAAA,EAIA;AACF;;;ACdO,IAAM,0BAAN,cAAsC,MAAM;AAAA,EAKjD,YAAY,SAAqB,MAAyB;AACxD,UAAM,IAAI,OAAO,oBAAoB,OAAO,GAAG,IAAI,cAAc,EAAE,iBAAiB;AALtF;AAME,SAAK,OAAO;AAAA,EACd;AACF;AAEO,IAAM,mBAAN,cAA+B,MAAM;AAAA,EAK1C,YAAY,MAAc,OAAe,MAAyB;AAChE,UAAM,IAAI,IAAI,oBAAoB,OAAO,GAAG,IAAI,cAAc,EAAE,SAAS;AAL3E;AAME,SAAK,OAAO;AACZ,SAAK,QAAQ;AAAA,EACf;AACF;AAEO,IAAM,oBAAN,cAAgC,MAAM;AAAA,EAG3C,YAAY,UAAkB;AAC5B,UAAM,IAAI,QAAQ,4BAA4B;AAHhD;AAAA,EAIA;AACF;AAEO,IAAM,oBAAN,cAAgC,MAAM;AAAA,EAG3C,YAAY,UAAkB;AAC5B,UAAM,IAAI,QAAQ,4BAA4B;AAHhD;AAAA,EAIA;AACF;AAEO,IAAM,6BAAN,cAAyC,MAAM;AAAA,EAGpD,YAAY,MAAc;AACxB,UAAM,KAAK,KAAK,SAAS,EAAE,EAAE,SAAS,GAAG,GAAG,CAAC,qCAAqC;AAHpF;AAAA,EAIA;AACF;AAEO,IAAM,oDAAN,cAAgE,MAAM;AAAA,EAG3E,YAAY,MAAc,aAA+C,WAAW;AAClF,UAAM,yBAAyB,KAAK,SAAS,EAAE,EAAE,SAAS,GAAG,GAAG,CAAC,gCAAgC,UAAU,EAAE;AAH/G;AAAA,EAIA;AACF;;;ACrDO,IAAM,0BAAN,cAAsC,MAAM;AAAA,EAGjD,YAAY,QAAgB,QAAgB;AAC1C,UAAM,gCAAgC,MAAM,SAAS,MAAM,WAAW;AAHxE;AAAA,EAIA;AACF;AAEO,IAAM,0BAAN,cAAsC,MAAM;AAAA,EAGjD,YAAY,QAAgB,QAAgB;AAC1C,UAAM,+BAA+B,MAAM,SAAS,MAAM,WAAW;AAHvE;AAAA,EAIA;AACF;AAEO,IAAM,0BAAN,cAAsC,MAAM;AAAA,EAGjD,YAAY,QAAgB,QAAgB;AAC1C,UAAM,oCAAoC,MAAM,SAAS,MAAM,WAAW;AAH5E;AAAA,EAIA;AACF;AAEO,IAAM,0BAAN,cAAsC,MAAM;AAAA,EAGjD,YAAY,QAAgB,QAAgB;AAC1C,UAAM,mCAAmC,MAAM,SAAS,MAAM,WAAW;AAH3E;AAAA,EAIA;AACF;AAEO,IAAM,mBAAN,cAA+B,UAAU;AAAA,EAG9C,cAAc;AACZ,UAAM,yDAAyD;AAHjE;AAAA,EAIA;AACF;AAEO,IAAM,oBAAN,cAAgC,UAAU;AAAA,EAG/C,cAAc;AACZ,UAAM,wCAAwC;AAHhD;AAAA,EAIA;AACF;AAEO,IAAM,mBAAN,cAA+B,MAAM;AAAA,EAG1C,YAAY,SAAiB,aAAqB;AAChD,UAAM,4BAA4B,WAAW,SAAS,OAAO,WAAW;AAH1E;AAAA,EAIA;AACF;AAEO,IAAM,qBAAN,cAAiC,UAAU;AAAA,EAGhD,cAAc;AACZ,UAAM,yCAAyC;AAHjD;AAAA,EAIA;AACF;AAEO,IAAM,mBAAN,cAA+B,UAAU;AAAA,EAG9C,cAAc;AACZ,UAAM,uCAAuC;AAH/C;AAAA,EAIA;AACF;AAEO,IAAM,wBAAN,cAAoC,UAAU;AAAA,EAGnD,cAAc;AACZ,UAAM,4CAA4C;AAHpD;AAAA,EAIA;AACF;AAEO,IAAM,uBAAN,cAAmC,MAAM;AAAA,EAG9C,YAAY,aAAqB,aAAqB;AACpD,UAAM,gCAAgC,WAAW,SAAS,WAAW,WAAW;AAHlF;AAAA,EAIA;AACF;;;ACtFO,IAAM,yBAAN,cAAqC,MAAM;AAAA,EAGhD,cAAc;AACZ,UAAM,gCAAgC;AAHxC;AAAA,EAIA;AACF;;;ACNO,IAAM,0BAAN,cAAsC,MAAM;AAAA,EAGjD,cAAc;AACZ,UAAM,qFAAqF;AAH7F;AAAA,EAIA;AACF;;;ACNO,IAAM,sBAAsB,CAAC,UAAkB;AACpD,MAAI,OAAO,UAAU,YAAY,CAAC,MAAM,WAAW,IAAI,KAAK,OAAO,MAAM,CAAC,KAAK,GAAG;AAChF,UAAM,IAAI,mBAAmB,KAAK;AAAA,EACpC;AACA,SAAO;AACT;AAEO,IAAM,8BAA8B,CAAC,UAA2B;AACrE,MAAI,OAAO,UAAU,UAAU;AAC7B,WAAO;AAAA,EACT;AACA,MAAI,OAAO,UAAU,UAAU;AAC7B,QAAI,CAAC,MAAM,WAAW,IAAI,GAAG;AAC3B,YAAM,IAAI,4BAA4B,KAAK;AAAA,IAC7C;AACA,WAAO;AAAA,EACT;AACA,QAAM,IAAI,UAAU,GAAG,KAAK,qCAAqC;AACnE;;;ACVO,IAAM,aAAa,CAAC,WAA4B;AACrD,8BAA4B,MAAM;AAClC,QAAM,KAAK,IAAI,SAAS,IAAI,YAAY,CAAC,CAAC;AAC1C,KAAG,UAAU,GAAG,OAAO,MAAM,GAAG,IAAI;AACpC,SAAO,KAAK,GAAG,UAAU,GAAG,KAAK,EAAE,SAAS,EAAE,EAAE,SAAS,GAAG,GAAG,CAAC;AAClE;AASO,IAAM,aAAa,CAAC,WAA4B;AACrD,8BAA4B,MAAM;AAClC,QAAM,KAAK,IAAI,SAAS,IAAI,YAAY,CAAC,CAAC;AAC1C,KAAG,UAAU,GAAG,OAAO,MAAM,GAAG,IAAI;AACpC,SAAO,KAAK,GAAG,UAAU,GAAG,KAAK,EAAE,SAAS,EAAE,EAAE,SAAS,GAAG,GAAG,CAAC;AAClE;AASO,IAAM,aAAa,CAAC,WAA4B;AACrD,8BAA4B,MAAM;AAClC,QAAM,OAAO,OAAO,WAAW,WAAW,OAAO,SAAS,EAAE,IAAI,OAAO,MAAM,CAAC,GAAG,SAAS,IAAI,GAAG;AACjG,QAAM,YAAY,WAAW,KAAK,IAAI,MAAM,GAAG,CAAC,CAAC,EAAE,EAAE,MAAM,CAAC;AAC5D,QAAM,WAAW,WAAW,KAAK,IAAI,MAAM,CAAC,CAAC,EAAE,EAAE,MAAM,CAAC;AACxD,SAAO,KAAK,QAAQ,GAAG,SAAS;AAClC;AAEO,IAAM,aAAa,CAAC,WAAqC;AAC9D,MAAI,WAAW,GAAI,QAAO,IAAI,WAAW;AACzC,MAAI,OAAO,WAAW,YAAY,CAAC,OAAO,WAAW,IAAI,GAAG;AAC1D,UAAM,IAAI,4BAA4B,MAAM;AAAA,EAC9C;AAEA,MAAI,MAAM,OAAO,SAAS,EAAE,EAAE,QAAQ,QAAQ,EAAE;AAChD,QAAM,IAAI,SAAS,IAAI,IAAI,GAAG,KAAK;AAEnC,QAAM,QAAkB,CAAC;AACzB,WAAS,IAAI,GAAG,IAAI,IAAI,QAAQ,KAAK,GAAG;AACtC,UAAM,KAAK,SAAS,IAAI,UAAU,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;AAAA,EAClD;AAEA,SAAO,IAAI,WAAW,KAAK;AAC7B;AASQ,IAAM,cAAc,CAAC,UAAkB;AAC7C,sBAAoB,KAAK;AACzB,QAAM,QAAQ,WAAW,KAAK;AAC9B,SAAO,KAAK,MAAM,YAAY,CAAC,KAAK,QAAQ,MAAM,IAAI,SAAS,EAAE,EAAE,SAAS,GAAG,GAAG,GAAG,EAAE,CAAC;AAC1F;AAEO,IAAM,aAAa,CAAC,UACzB,KAAK,CAAC,GAAG,KAAK,EAAE,IAAI,OAAK,EAAE,SAAS,EAAE,EAAE,SAAS,GAAG,GAAG,CAAC,EAAE,KAAK,EAAE,CAAC;;;ATnEpE,IAAM,KAAK,IAAI,GAAG,WAAW;AAMtB,IAAM,SAAN,MAAa;AAAA,EAKlB,YACE,IACA,EAAE,aAAa,KAAK,IAAa;AAAA,IAC/B,YAAY;AAAA,EACd,GACA;AAPF,SAAO,aAAsB;AAkC7B,SAAO,gBAAgB,CAAC,MAAa,UAAU;AAC7C,UAAI,QAAQ,OAAO;AACjB,eAAO,KAAK;AAAA,MACd;AACA,aAAO,KAAK,IAAI,WAAW,GAAG;AAAA,IAChC;AAEA,SAAO,eAAe,CAAC,QAAyB;AAC9C,UAAI,QAAQ,OAAO;AACjB,eAAO,KAAK;AAAA,MACd;AACA,aAAO,KAAK,IAAI,UAAU,KAAK,YAAY,GAAG;AAAA,IAChD;AAEA,SAAO,OAAO,CAAC,YAAyC;AACtD,YAAM,MAAM,OAAO,YAAY,WAAW,WAAW,OAAO,IAAI;AAChE,aAAO,KAAK,KAAK,IACd,KAAK,KAAK;AAAA,QACT,WAAW;AAAA,MACb,CAAC,EACA,MAAM,KAAK,CAAC;AAAA,IACjB;AAEA,SAAO,SAAS,CAAC,SAA0B,QAAyB;AAClE,YAAM,MAAM,OAAO,YAAY,WAAW,WAAW,OAAO,IAAI;AAChE,YAAM,YAAY,OAAO,QAAQ,WAAW,WAAW,GAAG,IAAI;AAC9D,aAAO,KAAK,IAAI,OAAO,KAAK,SAAgB;AAAA,IAC9C;AAEA,SAAO,kBAAkB,CAAC,YAAyC;AACjE,YAAM,MAAM,OAAO,YAAY,WAAW,WAAW,OAAO,IAAI;AAChE,YAAM,EAAE,GAAG,GAAG,cAAc,IAAI,KAAK,IAAI,KAAK,KAAK;AAAA,QACjD,WAAW;AAAA,MACb,CAAC;AACD,UAAI,kBAAkB,KAAM,OAAM,IAAI,qBAAqB;AAC3D,YAAM,OAAO,EAAE,SAAS,EAAE,EAAE,SAAS,IAAI,GAAG;AAC5C,YAAM,OAAO,EAAE,SAAS,EAAE,EAAE,SAAS,IAAI,GAAG;AAC5C,aAAO,KAAK,IAAI,GAAG,IAAI,IAAI,aAAa;AAAA,IAC1C;AAhEE,QAAI,OAAO,OAAW,OAAM,IAAI,2BAA2B,aAAa;AAExE,QAAI,OAAO,OAAO,YAAY,CAAC,GAAG,WAAW,IAAI,GAAG;AAClD,YAAM,IAAI,4BAA4B,EAAE;AAAA,IAC1C;AAEA,QAAI,OAAO,OAAO,YAAY,GAAG,WAAW,IAAI;AAC9C,YAAM,IAAI,uBAAuB;AAAA,IACnC;AAEA,QAAI,OAAO,OAAO,YAAY,GAAG,eAAe,IAAI;AAClD,YAAM,IAAI,uBAAuB;AAAA,IACnC;AAEA,SAAK,MAAM,GAAG,eAAe,OAAO,OAAO,WAAW,GAAG,QAAQ,OAAO,EAAE,IAAI,EAAE;AAChF,SAAK,aAAa;AAAA,EACpB;AAAA,EAEA,IAAI,aAAa;AACf,WAAO,KAAK,KAAK,IAAI,WAAW,KAAK,EAAE,SAAS,IAAI,GAAG,CAAC;AAAA,EAC1D;AAAA,EAEA,IAAI,YAAY;AACd,WAAO,KAAK,KAAK,IAAI,UAAU,KAAK,YAAY,KAAK,CAAW;AAAA,EAClE;AAyCF;;;AUrEO,IAAM,qBAA+C;AAAA,EAC1D,UAAU;AAAA,EACV,UAAU;AAAA,EACV,SAAS;AAAA,EACT,iBAAiB;AAAA,IACf,QAAQ;AAAA,IACR,OAAO;AAAA,EACT;AAAA,EACA,iBAAiB;AAAA,IACf,QAAQ;AAAA,IACR,OAAO;AAAA,EACT;AACF;AAQO,IAAM,qBAA+C;AAAA,EAC1D,UAAU;AAAA,EACV,UAAU;AAAA,EACV,SAAS;AAAA,EACT,iBAAiB;AAAA,IACf,QAAQ;AAAA,IACR,OAAO;AAAA,EACT;AAAA,EACA,iBAAiB;AAAA,IACf,QAAQ;AAAA,IACR,OAAO;AAAA,EACT;AACF;AAQO,IAAM,yBAA4E;AAAA,EACvF,UAAU;AAAA,EACV,UAAU;AAAA,EACV,SAAS;AAAA,EACT,iBAAiB;AAAA,IACf,QAAQ;AAAA,IACR,OAAO;AAAA,EACT;AACF;AAEO,IAAM,yBAA4E;AAAA,EACvF,UAAU;AAAA,EACV,UAAU;AAAA,EACV,SAAS;AAAA,EACT,iBAAiB;AAAA,IACf,QAAQ;AAAA,IACR,OAAO;AAAA,EACT;AACF;;;AC7DA,IAAM,mBAAmB;AAIlB,IAAK,gBAAL,kBAAKC,mBAAL;AACL,EAAAA,eAAA,aAAU;AACV,EAAAA,eAAA,aAAU;AAFA,SAAAA;AAAA,GAAA;AAKL,IAAK,cAAL,kBAAKC,iBAAL;AACL,EAAAA,aAAA,iBAAc;AACd,EAAAA,aAAA,aAAU;AACV,EAAAA,aAAA,kBAAe;AACf,EAAAA,aAAA,kBAAe;AAJL,SAAAA;AAAA,GAAA;AAOL,IAAK,aAAL,kBAAKC,gBAAL;AACL,EAAAA,YAAA,YAAS;AACT,EAAAA,YAAA,aAAU;AAFA,SAAAA;AAAA,GAAA;AAKZ,IAAK,WAAL,kBAAKC,cAAL;AACE,EAAAA,UAAA,UAAO;AACP,EAAAA,UAAA,UAAO;AACP,EAAAA,UAAA,WAAQ;AACR,EAAAA,UAAA,WAAQ;AAJL,SAAAA;AAAA,GAAA;AAUL,IAAM,mBAAmB,CAAC,SAAqB,YAAY,SACzD,QAAQ,OAAO,YAAY,sBAAwB,qBAAuB,QAAQ,QAAQ,OAAO,GAAG,gBAAgB;AAEtH,IAAM,kBAAkB,CAAC,EAAE,UAAU,UAAU,KAAK,MAAwC;AAC1F,MAAI,CAAC,KAAK,WAAW,IAAI,GAAG;AAC1B,UAAM,IAAI,4BAA4B,IAAI;AAAA,EAC5C;AAEA,MAAI,CAAC,SAAS,WAAW,IAAI,KAAK,SAAS,WAAW,IAAI;AACxD,UAAM,IAAI,kBAAkB,QAAQ;AAAA,EACtC;AAEA,MAAI,CAAC,SAAS,QAAQ,GAAG;AACvB,UAAM,IAAI,kBAAkB,QAAQ;AAAA,EACtC;AAEA,SAAO,WAAW,OAAO,SAAS,MAAM,CAAC,CAAC,GAAG,SAAS,QAAQ,CAAC,GAAG,KAAK,MAAM,CAAC,CAAC,EAAE;AACnF;AASO,IAAM,kBAAkB,CAAC,QAA8B,YAAY,SACxE,iBAAiB,gBAAgB,MAAM,GAAG,SAAS;AAyB9C,IAAM,mBAAmB,CAC9B,MACA,OAAoB,sBACpB,yBACA,aACe;AACf,MAAI,OAAO,SAAS,YAAY,CAAC,KAAK,WAAW,IAAI,GAAG;AACtD,UAAM,IAAI,4BAA4B,IAAI;AAAA,EAC5C;AAEA,MACE,CAAC,CAAC,sBAAqB,2BAA0B,2BAA0B,wBAAuB,EAAE,SAAS,IAAI,GACjH;AACA,UAAM,IAAI,2BAA2B,CAAC,IAAI;AAAA,EAC5C;AAEA,MAAI,CAAC,2BAA0B,yBAAwB,EAAE,SAAS,IAAI,GAAG;AAEvE,YAAQ;AAAA,MACN;AAAA,IACF;AAAA,EACF;AAEA,MAAI,CAAC,yBAAyB;AAC5B,8BAA0B,SAAS,uBAAsB,SAAS,mBAAmB;AAAA,EACvF;AAEA,MAAI,SAAS,0BAAyB;AACpC,WAAO,IAAI,WAAW;AAAA,MACpB,GAAG,WAAW,IAAI;AAAA,MAClB,GAAG,WAAW,uBAAuB;AAAA,MACrC,GAAI,OAAO,SAAS,WAAW,WAAW,IAAI,IAAI;AAAA,IACpD,CAAC;AAAA,EACH;AAEA,MAAI,CAAC,YAAY,4BAA4B,mBAAmB,UAAU;AACxE,eAAW,mBAAmB;AAAA,EAChC;AAEA,MAAI,CAAC,yBAAyB,WAAW,IAAI,KAAK,wBAAwB,WAAW,IAAI;AACvF,UAAM,IAAI,kBAAkB,uBAAuB;AAAA,EACrD;AAEA,MAAI,CAAC,UAAU;AACb,UAAM,IAAI,2BAA2B,UAAU;AAAA,EACjD;AAEA,SAAO,gBAAgB;AAAA,IACrB,UAAU;AAAA,IACV;AAAA,IACA,MAAM,OAAO,SAAS,WAAW,OAAO,WAAW,IAAI;AAAA,EACzD,CAAC;AACH;AAWO,IAAM,gBAAgB,CAC3B,MACA,EAAE,SAAS,qBAAuB,OAAO,sBAAqB,0BAA0B,GAAG,IAAoB,CAAC,MAC7G,OAAO,OAAO,QAAQ,OAAO,QAAQ,iBAAiB,MAAM,MAAM,uBAAuB,CAAC,GAAG,gBAAgB;AAY3G,IAAM,uBAAuB,CAAC;AAAA,EACnC;AAAA,EACA;AAAA,EACA,OAAO;AAAA,EACP;AACF,MAKM,cAAc,MAAM,EAAE,QAAQ,MAAM,yBAAyB,SAAS,CAAC;AAEtE,IAAM,kBAAkB,CAAC,QAA6B,UAA0B,CAAC,MAAM;AAC5F,QAAM,gBAAgB,SAAS,MAAM;AACrC,SAAO,cAAc,eAAe,OAAO;AAC7C;AAEA,IAAM,6BAA6B,CAAC,SAAqB,eAA4B;AACnF,QAAM,CAAC,MAAM,OAAO,GAAG,IAAI,IAAI;AAC/B,MAAI,eAAe,uBAAmB;AACpC,UAAM,IAAI,kDAAkD,MAAM,UAAU;AAAA,EAC9E;AAEA,UAAQ,OAAO;AAAA,IACb,KAAK;AAAA,IACL,KAAK,GAAG;AAEN,UAAI,KAAK,WAAW,IAAI;AACtB,cAAM,IAAI,wBAAwB,SAAS,OAAO;AAAA,MACpD;AACA;AAAA,IACF;AAAA,IACA,KAAK,GAAG;AAEN,UAAI,KAAK,WAAW,MAAM,KAAK,WAAW,MAAM,KAAK,WAAW,IAAI;AAClE;AAAA,MACF;AACA,YAAM,IAAI,wBAAwB,SAAS,OAAO;AAAA,IACpD;AAAA,IACA,SAAS;AACP,YAAM,IAAI,wBAAwB,SAAS,OAAO;AAAA,IACpD;AAAA,EACF;AAEF;AAEA,IAAM,iBAAiB,CAAC,SAAqB,eAA2B;AACtE,QAAM,OAAO,QAAQ,CAAC;AACtB,QAAM,OAAO,QAAQ,MAAM,CAAC;AAE5B,UAAQ,MAAM;AAAA,IACZ,KAAK,CAAC,sBAAqB;AACzB,iCAA2B,SAAS,UAAU;AAC9C;AAAA,IACF;AAAA,IACA,KAAK,CAAC;AAAA,IACN,KAAK,CAAC,2BAA0B;AAC9B,UAAI,eAAe,uBAAmB;AACpC,cAAM,IAAI,kDAAkD,MAAM,UAAU;AAAA,MAC9E;AACA,UAAI,KAAK,SAAS,IAAI;AACpB,cAAM,IAAI,wBAAwB,SAAS,MAAM;AAAA,MACnD;AACA;AAAA,IACF;AAAA,IACA,KAAK,CAAC,0BAAyB;AAC7B,UAAI,eAAe,yBAAoB;AACrC,cAAM,IAAI,kDAAkD,MAAM,UAAU;AAAA,MAC9E;AACA,YAAM,WAAW,KAAK,MAAM,GAAG,EAAE;AACjC,UAAI,SAAS,SAAS,IAAI;AACxB,cAAM,IAAI,kBAAkB,WAAW,QAAQ,CAAC;AAAA,MAClD;AAEA,YAAM,WAAW,SAAS,KAAK,EAAE,EAAE,SAAS,GAAG,EAAE;AACjD,UAAI,WAAW,KAAK,aAAa,GAAG;AAClC,cAAM,IAAI,kBAAkB,KAAK,SAAS,SAAS,EAAE,CAAC,EAAE;AAAA,MAC1D;AAEA;AAAA,IACF;AAAA,IACA,SAAS;AACP,YAAM,IAAI,wBAAwB,OAAO;AAAA,IAC3C;AAAA,EACF;AAEF;AAYO,IAAM,eAA6B,CAAC,SAAiB,SAA2B,aAAkB;AACvG,MAAI;AACJ,MAAI,UAAsB,IAAI,WAAW;AACzC,MAAI;AACF,UAAM,UAAU,OAAO,OAAO,SAAS,gBAAgB;AACvD,iBAAa;AACb,cAAU,IAAI,WAAW,OAAO,UAAU,IAAI,WAAW,QAAQ,KAAK,CAAC,CAAC;AAAA,EAC1E,QAAQ;AACN,UAAM,UAAU,QAAQ,OAAO,SAAS,gBAAgB;AACxD,iBAAa;AACb,cAAU,IAAI,WAAW,QAAQ,UAAU,IAAI,WAAW,QAAQ,KAAK,CAAC,CAAC;AAAA,EAC3E;AAEA,MAAI;AACF,mBAAe,SAAS,UAAU;AAAA,EACpC,SAAS,KAAU;AACjB,QAAI,eAAe,mDAAmD;AACpE,YAAM;AAAA,IACR;AACA,UAAM,IAAI,iBAAiB,SAAS,IAAI,OAAO,IAAI,IAAI;AAAA,EACzD;AACA,SAAO,WAAW,WAAW,UAAU,WAAW,OAAO;AAC3D;AAEO,IAAM,kBAAkB,CAAC,YAA0C;AACxE,QAAM,UAAU,aAAa,OAAO;AACpC,QAAM,OAAO,QAAQ,CAAC;AAEtB,UAAQ,MAAM;AAAA,IACZ,KAAK,CAAC,0BAAyB;AAC7B,YAAM,YAA0D;AAAA,QAC9D,MAAM;AAAA,QACN,MAAM;AAAA,QACN,MAAM;AAAA,QACN,MAAM;AAAA,MACR;AACA,YAAM,IAAI,WAAW,OAAO;AAE5B,YAAM,WAAW,KAAK,EAAE,UAAU,GAAG,EAAE,CAAC;AACxC,YAAM,WAAW,UAAU,EAAE,UAAU,IAAI,EAAE,CAAC;AAC9C,YAAM,OAAO,KAAK,EAAE,UAAU,EAAE,CAAC;AACjC,aAAO,EAAE,UAAU,UAAU,KAAK;AAAA,IACpC;AAAA,IACA,KAAK,CAAC,sBAAqB;AACzB,YAAM,kBAAkB;AAAA,QACtB;AAAA,QACA;AAAA,QACA,QAAQ,WAAW,mBAAqB,IAAI,yBAAyB;AAAA,MACvE;AACA,YAAM,QAAQ,QAAQ,CAAC;AACvB,YAAM,OAAO,QAAQ,MAAM,CAAC;AAC5B,YAAM,SAAS,gBAAgB,KAAK,KAAK;AACzC,aAAO;AAAA,QACL,UAAU,OAAO;AAAA,QACjB,UAAU,OAAO;AAAA,QACjB,MAAM,WAAW,IAAI;AAAA,MACvB;AAAA,IACF;AAAA,IACA,KAAK,CAAC;AAAA,IACN,KAAK,CAAC,2BAA0B;AAC9B,YAAM,kBAAkB,WAAW,QAAQ,MAAM,CAAC,CAAC;AACnD,YAAM,WAAW,SAAS,CAAC,4BAA2B,SAAS;AAC/D,aAAO;AAAA,QACL,UAAU,gBAAgB,UAAU,GAAG,EAAE;AAAA,QACzC;AAAA,QACA,MAAM,KAAK,gBAAgB,UAAU,EAAE,CAAC;AAAA,MAC1C;AAAA,IACF;AAAA,IACA,SAAS;AACP,YAAM,IAAI,2BAA2B,IAAI;AAAA,IAC3C;AAAA,EACF;AACF;;;AC/VA,SAAS,QAAQ,eAAe;;;ACehC,IAAM,YAAY;AAClB,IAAM,YAAY;AAElB,IAAM,eAAe;AACrB,IAAM,eAAe;AAErB,IAAM,YAAY;AAClB,IAAM,gBAAgB;AAEtB,IAAM,IAAI,IAAI,YAAY,EAAE;AAC5B,IAAM,IAAI,IAAI,YAAY,EAAE;AAS5B,IAAM,UAAU,CAAC,KAAkB,GAAW,MAAc;AAC1D,QAAM,KAAK,IAAI,CAAC,IAAI,IAAI,CAAC;AACzB,MAAI,KAAK,IAAI,IAAI,CAAC,IAAI,IAAI,IAAI,CAAC;AAC/B,MAAI,MAAM,YAAa;AACrB;AAAA,EACF;AACA,MAAI,CAAC,IAAI;AACT,MAAI,IAAI,CAAC,IAAI;AACf;AAUA,IAAM,UAAU,CAAC,KAAkB,GAAW,IAAY,OAAe;AACvE,MAAI,KAAK,IAAI,CAAC,IAAI;AAClB,MAAI,KAAK,GAAG;AACV,UAAM;AAAA,EACR;AACA,MAAI,KAAK,IAAI,IAAI,CAAC,IAAI;AACtB,MAAI,MAAM,YAAa;AACrB;AAAA,EACF;AACA,MAAI,CAAC,IAAI;AACT,MAAI,IAAI,CAAC,IAAI;AACf;AAGA,IAAM,YAAY,CAAC,KAAiB,MAAc;AAChD,SAAO,IAAI,CAAC,IAAK,IAAI,IAAI,CAAC,KAAK,IAAM,IAAI,IAAI,CAAC,KAAK,KAAO,IAAI,IAAI,CAAC,KAAK;AAC1E;AAIA,IAAM,QAAQ,CAAC,GAAW,GAAW,GAAW,GAAW,IAAY,OAAe;AACpF,QAAM,KAAK,EAAE,EAAE;AACf,QAAM,KAAK,EAAE,KAAK,CAAC;AACnB,QAAM,KAAK,EAAE,EAAE;AACf,QAAM,KAAK,EAAE,KAAK,CAAC;AAEnB,UAAQ,GAAG,GAAG,CAAC;AACf,UAAQ,GAAG,GAAG,IAAI,EAAE;AAGpB,MAAI,OAAO,EAAE,CAAC,IAAI,EAAE,CAAC;AACrB,MAAI,OAAO,EAAE,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC;AAC7B,IAAE,CAAC,IAAI;AACP,IAAE,IAAI,CAAC,IAAI;AAEX,UAAQ,GAAG,GAAG,CAAC;AAGf,SAAO,EAAE,CAAC,IAAI,EAAE,CAAC;AACjB,SAAO,EAAE,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC;AACzB,IAAE,CAAC,IAAK,SAAS,KAAO,QAAQ;AAChC,IAAE,IAAI,CAAC,IAAK,SAAS,KAAO,QAAQ;AAEpC,UAAQ,GAAG,GAAG,CAAC;AACf,UAAQ,GAAG,GAAG,IAAI,EAAE;AAGpB,SAAO,EAAE,CAAC,IAAI,EAAE,CAAC;AACjB,SAAO,EAAE,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC;AACzB,IAAE,CAAC,IAAK,SAAS,KAAO,QAAQ;AAChC,IAAE,IAAI,CAAC,IAAK,SAAS,KAAO,QAAQ;AAEpC,UAAQ,GAAG,GAAG,CAAC;AAGf,SAAO,EAAE,CAAC,IAAI,EAAE,CAAC;AACjB,SAAO,EAAE,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC;AACzB,IAAE,CAAC,IAAK,SAAS,KAAO,QAAQ;AAChC,IAAE,IAAI,CAAC,IAAK,SAAS,KAAO,QAAQ;AACtC;AAIA,IAAM,eAAe,IAAI,YAAY;AAAA,EACnC;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EACpC;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EACpC;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AAAA,EACpC;AAAA,EAAY;AAAA,EAAY;AAAA,EAAY;AACtC,CAAC;AAED,IAAM,SAAS;AAAA,EACb;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAClD;AAAA,EAAI;AAAA,EAAI;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAI;AAAA,EAAI;AAAA,EAAG;AAAA,EAAG;AAAA,EAAI;AAAA,EAAG;AAAA,EAAG;AAAA,EAAI;AAAA,EAAG;AAAA,EAAG;AAAA,EACnD;AAAA,EAAI;AAAA,EAAG;AAAA,EAAI;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EACnD;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAI;AAAA,EAAG;AAAA,EAAG;AAAA,EAAI;AAAA,EACnD;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAG;AAAA,EAAI;AAAA,EAAI;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAClD;AAAA,EAAG;AAAA,EAAI;AAAA,EAAG;AAAA,EAAI;AAAA,EAAG;AAAA,EAAI;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAI;AAAA,EAAG;AAAA,EAAG;AAAA,EAAI;AAAA,EAAI;AAAA,EAAG;AAAA,EACnD;AAAA,EAAI;AAAA,EAAG;AAAA,EAAG;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAG;AAAA,EAAI;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAClD;AAAA,EAAI;AAAA,EAAI;AAAA,EAAG;AAAA,EAAI;AAAA,EAAI;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAI;AAAA,EAAG;A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","sourcesContent":["import axios from 'axios'\nimport Base from './base'\nimport paramsFormatter from './paramsFormatter'\nimport * as resultFormatter from './resultFormatter'\nimport { MethodInBatchNotFoundException, PayloadInBatchException, IdNotMatchedInBatchException } from './exceptions'\nimport { CKBComponents } from '../types'\nimport { Method } from './method'\n\nexport { Method }\n\nexport class BranchRPC extends Base {\n  #node: CKBComponents.Node = {\n    url: '',\n  }\n\n  get node() {\n    return this.#node\n  }\n\n  #paramsFormatter = paramsFormatter\n\n  get paramsFormatter() {\n    return this.#paramsFormatter\n  }\n\n  #resultFormatter = resultFormatter\n\n  get resultFormatter() {\n    return this.#resultFormatter\n  }\n\n  constructor(url: string) {\n    super()\n    this.setNode({ url })\n\n    Object.defineProperties(this, {\n      addMethod: { value: this.addMethod, enumerable: false, writable: false, configurable: false },\n      setNode: { value: this.setNode, enumerable: false, writable: false, configurable: false },\n      createBatchRequest: { value: this.createBatchRequest, enumerable: false, writable: false, configurable: false },\n    })\n\n    Object.keys(this.rpcProperties).forEach(name => {\n      this.addMethod({ name, ...this.rpcProperties[name] })\n    })\n  }\n\n  public setNode(node: CKBComponents.Node): CKBComponents.Node {\n    Object.assign(this.node, node)\n    return this.node\n  }\n\n  public addMethod = (options: CKBComponents.Method) => {\n    const method = new Method(this.node, options)\n\n    Object.defineProperty(this, options.name, {\n      value: method.call,\n      enumerable: true,\n    })\n  }\n\n  /* eslint-disable prettier/prettier */\n  public createBatchRequest = <N extends keyof Base, P extends (string | number | object)[], R = any[]>(\n    params: [method: N, ...rest: P][] = [],\n  ) => {\n    const ctx = this\n\n    const proxied: [method: N, ...rest: P][] = new Proxy([], {\n      set(...p) {\n        const methods = Object.keys(ctx)\n        if (p[1] !== 'length') {\n          const name = p?.[2]?.[0]\n          if (methods.indexOf(name) === -1) {\n            throw new MethodInBatchNotFoundException(name)\n          }\n        }\n        return Reflect.set(...p)\n      },\n    })\n\n    Object.defineProperties(proxied, {\n      add: {\n        value(...args: P) {\n          this.push(args)\n          return this\n        },\n      },\n      remove: {\n        value(i: number) {\n          this.splice(i, 1)\n          return this\n        },\n      },\n      exec: {\n        async value() {\n          const payload = proxied.map(([f, ...p], i) => {\n            try {\n              const method = new Method(ctx.node, { ...ctx.rpcProperties[f], name: f })\n              return method.getPayload(...p)\n            } catch (err: any) {\n              throw new PayloadInBatchException(i, err.message)\n            }\n          })\n\n          if (!payload.length) {\n            return []\n          }\n\n          const batchRes = await axios({\n            method: 'POST',\n            headers: { 'content-type': 'application/json' },\n            data: payload,\n            url: ctx.#node.url,\n            httpAgent: ctx.#node.httpAgent,\n            httpsAgent: ctx.#node.httpsAgent,\n          })\n\n          return batchRes.data.map((res: any, i: number) => {\n            if (res.id !== payload[i].id) {\n              return new IdNotMatchedInBatchException(i, payload[i].id, res.id)\n            }\n            return ctx.rpcProperties[proxied[i][0]].resultFormatters?.(res.result) ?? res.result\n          })\n        },\n      },\n    })\n    params.forEach(p => proxied.push(p))\n\n    return proxied as typeof proxied & {\n      add: (n: N, ...p: P) => typeof proxied\n      remove: (index: number) => typeof proxied\n      exec: () => Promise<R>\n    }\n  }\n}\n","import JSBI from 'jsbi'\nimport { ECPair } from './ecpair'\nimport { hexToBytes, toBigEndian } from './convertors'\nimport { pubkeyToAddress, AddressOptions } from './address'\nimport { ParameterRequiredException, HexStringWithout0xException } from './exceptions'\nimport { blake2b } from './crypto'\nimport { serializeScript } from './serialization'\nimport { cellOccupied } from './occupiedCapacity'\nimport { serializeRawTransaction } from './serialization/transaction'\nimport { PERSONAL } from './const'\nimport { CKBComponents } from '../types'\n\nexport * from './address'\nexport * from './serialization'\nexport * from './convertors'\nexport * from './epochs'\nexport * from './sizes'\nexport * from './crypto'\nexport * from './occupiedCapacity'\nexport * from './systemScripts'\nexport * from './reconcilers'\nexport * from './calculateTransactionFee'\nexport * from './const'\nexport * from './ecpair'\nexport * from './validators'\nexport * from './exceptions'\nexport { JSBI } \n\nexport const scriptToHash = (script: CKBComponents.Script) => {\n  if (!script) throw new ParameterRequiredException('Script')\n  const serializedScript = serializeScript(script)\n  const s = blake2b(32, null, null, PERSONAL)\n  s.update(hexToBytes(serializedScript))\n  const digest = s.digest('hex')\n  return `0x${digest}` as string\n}\n\nexport const rawTransactionToHash = (rawTransaction: Omit<CKBComponents.RawTransaction, 'witnesses'>) => {\n  if (!rawTransaction) throw new ParameterRequiredException('Raw transaction')\n  const serializedRawTransaction = serializeRawTransaction(rawTransaction)\n  const s = blake2b(32, null, null, PERSONAL)\n  s.update(hexToBytes(serializedRawTransaction))\n  const digest = s.digest('hex')\n  return `0x${digest}` as string\n}\n\nexport const privateKeyToPublicKey = (privateKey: string) => {\n  const keyPair = new ECPair(privateKey)\n  return keyPair.publicKey\n}\n\nexport const privateKeyToAddress = (privateKey: string, options: AddressOptions) =>\n  pubkeyToAddress(privateKeyToPublicKey(privateKey), options)\n\nexport const extractDAOData = (dao: CKBComponents.DAO) => {\n  if (!dao.startsWith('0x')) {\n    throw new HexStringWithout0xException(dao)\n  }\n  const value = dao.replace('0x', '')\n  return {\n    c: toBigEndian(`0x${value.slice(0, 16)}`),\n    ar: toBigEndian(`0x${value.slice(16, 32)}`),\n    s: toBigEndian(`0x${value.slice(32, 48)}`),\n    u: toBigEndian(`0x${value.slice(48, 64)}`)\n  }\n}\n\nexport const calculateMaximumWithdraw = (\n  outputCell: CKBComponents.CellOutput,\n  outputDataCapacity: CKBComponents.Bytes,\n  depositDAO: CKBComponents.DAO,\n  withdrawDAO: CKBComponents.DAO\n) => {\n    const depositCellSerialized = cellOccupied(outputCell) + outputDataCapacity.slice(2).length / 2\n    const occupiedCapacity = JSBI.asUintN(\n      128,\n      JSBI.multiply(JSBI.BigInt(100000000), JSBI.BigInt(depositCellSerialized))\n    )\n    return `0x${JSBI.add(\n      JSBI.divide(\n        JSBI.multiply(\n          JSBI.subtract(\n            JSBI.asUintN(128, JSBI.BigInt(outputCell.capacity)),\n            occupiedCapacity\n          ),\n          JSBI.asUintN(128, JSBI.BigInt(extractDAOData(withdrawDAO).ar))\n        ),\n        JSBI.asUintN(128, JSBI.BigInt(extractDAOData(depositDAO).ar))\n      ),\n      occupiedCapacity\n    ).toString(16)}`\n}\n","import { ec as EC } from 'elliptic'\n\nimport { hexToBytes } from './convertors'\nimport {\n  HexStringWithout0xException,\n  ParameterRequiredException,\n  PrivateKeyLenException,\n  SignMessageException,\n} from './exceptions'\n\nconst ec = new EC('secp256k1')\n\nexport interface Options {\n  compressed?: boolean\n}\n\nexport class ECPair {\n  protected key: EC.KeyPair\n\n  public compressed: boolean = false\n\n  constructor(\n    sk: Uint8Array | string,\n    { compressed = true }: Options = {\n      compressed: true,\n    },\n  ) {\n    if (sk === undefined) throw new ParameterRequiredException('Private key')\n\n    if (typeof sk === 'string' && !sk.startsWith('0x')) {\n      throw new HexStringWithout0xException(sk)\n    }\n\n    if (typeof sk === 'string' && sk.length !== 66) {\n      throw new PrivateKeyLenException()\n    }\n\n    if (typeof sk === 'object' && sk.byteLength !== 32) {\n      throw new PrivateKeyLenException()\n    }\n\n    this.key = ec.keyFromPrivate(typeof sk === 'string' ? sk.replace(/^0x/, '') : sk)\n    this.compressed = compressed\n  }\n\n  get privateKey() {\n    return `0x${this.key.getPrivate('hex').padStart(64, '0')}`\n  }\n\n  get publicKey() {\n    return `0x${this.key.getPublic(this.compressed, 'hex') as string}`\n  }\n\n  public getPrivateKey = (enc: 'hex' = 'hex') => {\n    if (enc === 'hex') {\n      return this.privateKey\n    }\n    return this.key.getPrivate(enc)\n  }\n\n  public getPublicKey = (enc: 'hex' | 'array') => {\n    if (enc === 'hex') {\n      return this.publicKey\n    }\n    return this.key.getPublic(this.compressed, enc)\n  }\n\n  public sign = (message: string | Uint8Array): string => {\n    const msg = typeof message === 'string' ? hexToBytes(message) : message\n    return `0x${this.key\n      .sign(msg, {\n        canonical: true,\n      })\n      .toDER('hex')}`\n  }\n\n  public verify = (message: string | Buffer, sig: string | Buffer) => {\n    const msg = typeof message === 'string' ? hexToBytes(message) : message\n    const signature = typeof sig === 'string' ? hexToBytes(sig) : sig\n    return this.key.verify(msg, signature as any)\n  }\n\n  public signRecoverable = (message: string | Uint8Array): string => {\n    const msg = typeof message === 'string' ? hexToBytes(message) : message\n    const { r, s, recoveryParam } = this.key.sign(msg, {\n      canonical: true,\n    })\n    if (recoveryParam === null) throw new SignMessageException()\n    const fmtR = r.toString(16).padStart(64, '0')\n    const fmtS = s.toString(16).padStart(64, '0')\n    return `0x${fmtR}${fmtS}0${recoveryParam}`\n  }\n}\n\n","export enum ErrorCode {\n  ParameterInvalid = 101,\n  ParameterRequired,\n  SignMessageFailed,\n  AddressInvalid,\n  ReconciliationFailed,\n}\n\n","import { ErrorCode } from './ErrorCode'\n\nexport class ParameterRequiredException extends Error {\n  code = ErrorCode.ParameterRequired\n\n  constructor(name: string) {\n    super(`${name} is required`)\n  }\n}\n\nexport class SignMessageException extends Error {\n  code = ErrorCode.SignMessageFailed\n\n  constructor() {\n    super('Fail to sign the message')\n  }\n}\n","import { ErrorCode } from './ErrorCode'\n\nexport class HexStringException extends Error {\n  code = ErrorCode.ParameterInvalid\n\n  constructor(hex: string) {\n    super(`${hex} is an invalid hex string`)\n  }\n}\n\nexport class HexStringWithout0xException extends Error {\n  code = ErrorCode.ParameterInvalid\n\n  constructor(hex: string) {\n    super(`Hex string ${hex} should start with 0x`)\n  }\n}\n","import { ErrorCode } from './ErrorCode'\n\nexport class AddressPayloadException extends Error {\n  code = ErrorCode.AddressInvalid\n\n  type: 'short' | 'full' | undefined\n\n  constructor(payload: Uint8Array, type?: 'short' | 'full') {\n    super(`'${payload}' is not a valid ${type ? `${type} version ` : ''}address payload`)\n    this.type = type\n  }\n}\n\nexport class AddressException extends Error {\n  code = ErrorCode.AddressInvalid\n\n  type: 'short' | 'full' | undefined\n\n  constructor(addr: string, stack: string, type?: 'short' | 'full') {\n    super(`'${addr}' is not a valid ${type ? `${type} version ` : ''}address`)\n    this.type = type\n    this.stack = stack\n  }\n}\n\nexport class CodeHashException extends Error {\n  code = ErrorCode.AddressInvalid\n\n  constructor(codeHash: string) {\n    super(`'${codeHash}' is not a valid code hash`)\n  }\n}\n\nexport class HashTypeException extends Error {\n  code = ErrorCode.AddressInvalid\n\n  constructor(hashType: string) {\n    super(`'${hashType}' is not a valid hash type`)\n  }\n}\n\nexport class AddressFormatTypeException extends Error {\n  code = ErrorCode.AddressInvalid\n\n  constructor(type: number) {\n    super(`0x${type.toString(16).padStart(2, '0')} is not a valid address format type`)\n  }\n}\n\nexport class AddressFormatTypeAndEncodeMethodNotMatchException extends Error {\n  code = ErrorCode.AddressInvalid\n\n  constructor(type: number, bech32Type: 'bech32' | 'bech32m' | 'unknown' = 'unknown') {\n    super(`Address format type 0x${type.toString(16).padStart(2, '0')} doesn't match encode method ${bech32Type}`)\n  }\n}\n","import { ErrorCode } from './ErrorCode'\n\nexport class OutLenTooSmallException extends Error {\n  code = ErrorCode.ParameterInvalid\n\n  constructor(outlen: number, minLen: number) {\n    super(`Expect outlen to be at least ${minLen}, but ${outlen} received`)\n  }\n}\n\nexport class OutLenTooLargeException extends Error {\n  code = ErrorCode.ParameterInvalid\n\n  constructor(outlen: number, maxLen: number) {\n    super(`Expect outlen to be at most ${maxLen}, but ${outlen} received`)\n  }\n}\n\nexport class KeyLenTooSmallException extends Error {\n  code = ErrorCode.ParameterInvalid\n\n  constructor(keyLen: number, minLen: number) {\n    super(`Expect key length to be at least ${minLen}, but ${keyLen} received`)\n  }\n}\n\nexport class KeyLenTooLargeException extends Error {\n  code = ErrorCode.ParameterInvalid\n\n  constructor(keyLen: number, maxLen: number) {\n    super(`Expect key length to be at most ${maxLen}, but ${keyLen} received`)\n  }\n}\n\nexport class OutTypeException extends TypeError {\n  code = ErrorCode.ParameterInvalid\n\n  constructor() {\n    super(`Expect out to be \"binary\", \"hex\", Uint8Array, or Buffer`)\n  }\n}\n\nexport class SaltTypeException extends TypeError {\n  code = ErrorCode.ParameterInvalid\n\n  constructor() {\n    super(`Expect salt to be Uint8Array or Buffer`)\n  }\n}\n\nexport class SaltLenException extends Error {\n  code = ErrorCode.ParameterInvalid\n\n  constructor(saltLen: number, requiredLen: number) {\n    super(`Expect salt length to be ${requiredLen}, but ${saltLen} received`)\n  }\n}\n\nexport class InputTypeException extends TypeError {\n  code = ErrorCode.ParameterInvalid\n\n  constructor() {\n    super(`Expect input to be Uint8Array or Buffer`)\n  }\n}\n\nexport class KeyTypeException extends TypeError {\n  code = ErrorCode.ParameterInvalid\n\n  constructor() {\n    super(`Expect key to be Uint8Array or Buffer`)\n  }\n}\n\nexport class PersonalTypeException extends TypeError {\n  code = ErrorCode.ParameterInvalid\n\n  constructor() {\n    super(`Expect PERSONAL to be Uint8Array or Buffer`)\n  }\n}\n\nexport class PersonalLenException extends Error {\n  code = ErrorCode.ParameterInvalid\n\n  constructor(personalLen: number, requiredLen: number) {\n    super(`Expect PERSONAL length to be ${requiredLen}, but ${personalLen} received`)\n  }\n}\n\n","import { ErrorCode } from './ErrorCode'\n\nexport class PrivateKeyLenException extends Error {\n  code = ErrorCode.ParameterInvalid\n\n  constructor() {\n    super('Private key has invalid length')\n  }\n}\n","import { ErrorCode } from './ErrorCode'\n\nexport class ReconciliationException extends Error {\n  code = ErrorCode.ReconciliationFailed\n\n  constructor() {\n    super(`Fail to reconcile transaction, try to increase extra count or check the transaction`)\n  }\n}\n","import { HexStringException, HexStringWithout0xException } from './exceptions'\n\nexport const assertToBeHexString = (value: string) => {\n  if (typeof value !== 'string' || !value.startsWith('0x') || Number.isNaN(+value)) {\n    throw new HexStringException(value)\n  }\n  return true\n}\n\nexport const assertToBeHexStringOrBigint = (value: string | bigint) => {\n  if (typeof value === 'bigint') {\n    return true\n  }\n  if (typeof value === 'string') {\n    if (!value.startsWith('0x')) {\n      throw new HexStringWithout0xException(value)\n    }\n    return true\n  }\n  throw new TypeError(`${value} should be type of string or bigint`)\n}\n","import { assertToBeHexStringOrBigint, assertToBeHexString } from '../validators'\nimport { HexStringWithout0xException } from '../exceptions'\n\n/**\n * Converts an uint16 into a hex string in little endian\n *\n * @memberof convertors\n * @param {string|bigint} uint16 The uint16 to convert\n * @returns {string} Returns a hex string\n */\nexport const toUint16Le = (uint16: string | bigint) => {\n  assertToBeHexStringOrBigint(uint16)\n  const dv = new DataView(new ArrayBuffer(2))\n  dv.setUint16(0, Number(uint16), true)\n  return `0x${dv.getUint16(0, false).toString(16).padStart(4, '0')}`\n}\n\n/**\n * Converts an uint32 into a hex string in little endian\n *\n * @memberof convertors\n * @param {string|bigint} uint32 The uint32 to convert\n * @returns {string} Returns a hex string\n */\nexport const toUint32Le = (uint32: string | bigint) => {\n  assertToBeHexStringOrBigint(uint32)\n  const dv = new DataView(new ArrayBuffer(4))\n  dv.setUint32(0, Number(uint32), true)\n  return `0x${dv.getUint32(0, false).toString(16).padStart(8, '0')}`\n}\n\n/**\n * Converts an uint64 into a hex string in little endian\n *\n * @memberof convertors\n * @param {string|bigint} uint64 The uint64 to convert\n * @returns {string} Returns a hex string\n */\nexport const toUint64Le = (uint64: string | bigint) => {\n  assertToBeHexStringOrBigint(uint64)\n  const val = (typeof uint64 === 'bigint' ? uint64.toString(16) : uint64.slice(2)).padStart(16, '0')\n  const viewRight = toUint32Le(`0x${val.slice(0, 8)}`).slice(2)\n  const viewLeft = toUint32Le(`0x${val.slice(8)}`).slice(2)\n  return `0x${viewLeft}${viewRight}`\n}\n\nexport const hexToBytes = (rawhex: string | number | bigint) => {\n  if (rawhex === '') return new Uint8Array()\n  if (typeof rawhex === 'string' && !rawhex.startsWith('0x')) {\n    throw new HexStringWithout0xException(rawhex)\n  }\n\n  let hex = rawhex.toString(16).replace(/^0x/i, '')\n  hex = hex.length % 2 ? `0${hex}` : hex\n\n  const bytes: number[] = []\n  for (let c = 0; c < hex.length; c += 2) {\n    bytes.push(parseInt(hex.substring(c, c + 2), 16))\n  }\n\n  return new Uint8Array(bytes)\n}\n\n/**\n * Converts a hex string in little endian into big endian\n *\n * @memberof convertors\n * @param {string} le16 The hex string to convert\n * @returns {string} Returns a big endian\n */\n export const toBigEndian = (leHex: string) => {\n  assertToBeHexString(leHex)\n  const bytes = hexToBytes(leHex);\n  return `0x${bytes.reduceRight((pre, cur) => pre + cur.toString(16).padStart(2, '0'), '')}`\n}\n\nexport const bytesToHex = (bytes: Uint8Array): string =>\n  `0x${[...bytes].map(b => b.toString(16).padStart(2, '0')).join('')}`\n","import { CKBComponents } from \"../types\"\n\n/**\n * @summary System scripts are the smart contracts built and deployed by the CKB core team.\n *          System scripts complement the function of CKB in a flexible way.\n *          System scripts can provide\n *          -  core functions (e.g. secp256k1/blake160 and Nervos DAO),\n *          -  shared standard implementations (e.g. Simple UDT),\n *          -  or other auxiliary infrastructure components.\n * @see https://github.com/nervosnetwork/rfcs/blob/master/rfcs/0024-ckb-system-script-list/0024-ckb-system-script-list.md\n */\ninterface SystemScript extends Omit<CKBComponents.Script, 'args'> {\n  depType: CKBComponents.DepType\n}\n\ntype OutPoints = Record<'mainnetOutPoint' | 'testnetOutPoint', CKBComponents.OutPoint>\n\n/**\n * @memberof System Scripts\n * @typedef {Lock Script}\n * @name SECP256K1_BLAKE160\n * @description SECP256K1_BLAKE160 is the default lock script to verify CKB transaction signature\n */\nexport const SECP256K1_BLAKE160: SystemScript & OutPoints = {\n  codeHash: '0x9bd7e06f3ecf4be0f2fcd2188b23f1b9fcc88e5d4b65a8637b17723bbda3cce8',\n  hashType: 'type',\n  depType: 'depGroup',\n  mainnetOutPoint: {\n    txHash: '0x71a7ba8fc96349fea0ed3a5c47992e3b4084b031a42264a018e0072e8172e46c',\n    index: '0x0',\n  },\n  testnetOutPoint: {\n    txHash: '0xf8de3bb47d055cdf460d93a2a6e1b05f7432f9777c8c474abf4eec1d4aee5d37',\n    index: '0x0',\n  },\n}\n\n/**\n * @memberof System Scripts\n * @typedef {Lock Script}\n * @name SECP256K1_MULTISIG\n * @description SECP256K1_MULTISIG is a script which allows a group of users to sign a single transaction\n */\nexport const SECP256K1_MULTISIG: SystemScript & OutPoints = {\n  codeHash: '0x5c5069eb0857efc65e1bca0c07df34c31663b3622fd3876c876320fc9634e2a8',\n  hashType: 'type',\n  depType: 'depGroup',\n  mainnetOutPoint: {\n    txHash: '0x71a7ba8fc96349fea0ed3a5c47992e3b4084b031a42264a018e0072e8172e46c',\n    index: '0x1',\n  },\n  testnetOutPoint: {\n    txHash: '0xf8de3bb47d055cdf460d93a2a6e1b05f7432f9777c8c474abf4eec1d4aee5d37',\n    index: '0x1',\n  },\n}\n\n/**\n * @memberof System Scripts\n * @typedef {Lock Script}\n * @name ANYONE_CAN_PAY\n * @description ANYONE_CAN_PAY allows a recipient to provide cell capacity in asset transfer\n */\nexport const ANYONE_CAN_PAY_MAINNET: SystemScript & Pick<OutPoints, 'mainnetOutPoint'> = {\n  codeHash: '0xd369597ff47f29fbc0d47d2e3775370d1250b85140c670e4718af712983a2354',\n  hashType: 'type',\n  depType: 'depGroup',\n  mainnetOutPoint: {\n    txHash: '0x4153a2014952d7cac45f285ce9a7c5c0c0e1b21f2d378b82ac1433cb11c25c4d',\n    index: '0x0',\n  },\n}\n\nexport const ANYONE_CAN_PAY_TESTNET: SystemScript & Pick<OutPoints, 'testnetOutPoint'> = {\n  codeHash: '0x3419a1c09eb2567f6552ee7a8ecffd64155cffe0f1796e6e61ec088d740c1356',\n  hashType: 'type',\n  depType: 'depGroup',\n  testnetOutPoint: {\n    txHash: '0xec26b0f85ed839ece5f11c4c4e837ec359f5adc4420410f6453b1f6b60fb96a6',\n    index: '0x0',\n  },\n}\n","import { blake160, bech32, bech32m } from '..'\nimport {\n  SECP256K1_BLAKE160,\n  SECP256K1_MULTISIG,\n  ANYONE_CAN_PAY_MAINNET,\n  ANYONE_CAN_PAY_TESTNET,\n} from '../systemScripts'\nimport { hexToBytes, bytesToHex } from '../convertors'\nimport {\n  HexStringWithout0xException,\n  AddressException,\n  AddressPayloadException,\n  CodeHashException,\n  HashTypeException,\n  ParameterRequiredException,\n  AddressFormatTypeException,\n  AddressFormatTypeAndEncodeMethodNotMatchException,\n} from '../exceptions'\nimport { CKBComponents } from '../../types'\n\nconst MAX_BECH32_LIMIT = 1023\n\n// TODO: deprecate outdated methods\n\nexport enum AddressPrefix {\n  Mainnet = 'ckb',\n  Testnet = 'ckt',\n}\n\nexport enum AddressType {\n  FullVersion = '0x00', // full version identifies the hash_type\n  HashIdx = '0x01', // short version for locks with popular codehash\n  DataCodeHash = '0x02', // full version with hash type 'Data', deprecated\n  TypeCodeHash = '0x04', // full version with hash type 'Type', deprecated\n}\n\nexport enum Bech32Type {\n  Bech32 = 'bech32',\n  Bech32m = 'bech32m',\n}\n\nenum HashType {\n  data = '00',\n  type = '01',\n  data1 = '02',\n  data2 = '04',\n}\n\n/**\n * @description payload to a full address of new version\n */\nconst payloadToAddress = (payload: Uint8Array, isMainnet = true) =>\n  bech32m.encode(isMainnet ? AddressPrefix.Mainnet : AddressPrefix.Testnet, bech32m.toWords(payload), MAX_BECH32_LIMIT)\n\nconst scriptToPayload = ({ codeHash, hashType, args }: CKBComponents.Script): Uint8Array => {\n  if (!args.startsWith('0x')) {\n    throw new HexStringWithout0xException(args)\n  }\n\n  if (!codeHash.startsWith('0x') || codeHash.length !== 66) {\n    throw new CodeHashException(codeHash)\n  }\n\n  if (!HashType[hashType]) {\n    throw new HashTypeException(hashType)\n  }\n\n  return hexToBytes(`0x00${codeHash.slice(2)}${HashType[hashType]}${args.slice(2)}`)\n}\n\n/**\n * @function scriptToAddress\n * @description The only way recommended to generated a full address of new version\n * @param {object} script\n * @param {booealn} isMainnet\n * @returns {string} address\n */\nexport const scriptToAddress = (script: CKBComponents.Script, isMainnet = true) =>\n  payloadToAddress(scriptToPayload(script), isMainnet)\n\n/**\n * 0x00 SECP256K1 + blake160\n * 0x01 SECP256k1 + multisig\n * 0x02 anyone_can_pay\n */\nexport type CodeHashIndex = '0x00' | '0x01' | '0x02'\n\nexport interface AddressOptions {\n  prefix?: AddressPrefix\n  type?: AddressType\n  codeHashOrCodeHashIndex?: CodeHashIndex | CKBComponents.Hash256\n}\n\n/**\n * @function toAddressPayload\n * @description obsolete payload = type(01) | code hash index(00) | args(blake160-formatted pubkey)\n *             new payload = type(00) | code hash | hash type(00|01|02) | args\n * @see https://github.com/nervosnetwork/rfcs/blob/master/rfcs/0021-ckb-address-format/0021-ckb-address-format.md\n * @param {string | Uint8Array} args, use as the identifier of an address, usually the public key hash is used.\n * @param {string} type, used to indicate which format is adopted to compose the address.\n * @param {string} codeHashOrCodeHashIndex, the referenced code hash or code hash index the address binds to,\n *                 default to be secp256k1 code hash/code hash index\n */\nexport const toAddressPayload = (\n  args: string | Uint8Array,\n  type: AddressType = AddressType.HashIdx,\n  codeHashOrCodeHashIndex?: CodeHashIndex | CKBComponents.Hash256,\n  hashType?: CKBComponents.ScriptHashType,\n): Uint8Array => {\n  if (typeof args === 'string' && !args.startsWith('0x')) {\n    throw new HexStringWithout0xException(args)\n  }\n\n  if (\n    ![AddressType.HashIdx, AddressType.DataCodeHash, AddressType.TypeCodeHash, AddressType.FullVersion].includes(type)\n  ) {\n    throw new AddressFormatTypeException(+type)\n  }\n\n  if ([AddressType.DataCodeHash, AddressType.TypeCodeHash].includes(type)) {\n    /* eslint-disable max-len */\n    console.warn(\n      `Address of 'AddressType.DataCodeHash' or 'AddressType.TypeCodeHash' is deprecated, please use address of AddressPrefix.FullVersion`,\n    )\n  }\n\n  if (!codeHashOrCodeHashIndex) {\n    codeHashOrCodeHashIndex = type === AddressType.HashIdx ? '0x00' : SECP256K1_BLAKE160.codeHash\n  }\n\n  if (type !== AddressType.FullVersion) {\n    return new Uint8Array([\n      ...hexToBytes(type),\n      ...hexToBytes(codeHashOrCodeHashIndex),\n      ...(typeof args === 'string' ? hexToBytes(args) : args),\n    ])\n  }\n\n  if (!hashType && codeHashOrCodeHashIndex === SECP256K1_BLAKE160.codeHash) {\n    hashType = SECP256K1_BLAKE160.hashType\n  }\n\n  if (!codeHashOrCodeHashIndex?.startsWith('0x') || codeHashOrCodeHashIndex.length !== 66) {\n    throw new CodeHashException(codeHashOrCodeHashIndex)\n  }\n\n  if (!hashType) {\n    throw new ParameterRequiredException('hashType')\n  }\n\n  return scriptToPayload({\n    codeHash: codeHashOrCodeHashIndex,\n    hashType,\n    args: typeof args === 'string' ? args : bytesToHex(args),\n  })\n}\n\n/**\n * @function bech32Address\n * @description generate the address by bech32 algorithm\n * @param args, used as the identifier of an address, usually the public key hash is used.\n * @param {[string]} prefix, the prefix precedes the address, default to be ckb.\n * @param {[string]} type, used to indicate which format is adopted to compose the address, default to be 0x01.\n * @param {[string]} codeHashOrCodeHashIndex, the referenced code hash or code hash index the address binds to,\n *                                            default to be 0x00.\n */\nexport const bech32Address = (\n  args: Uint8Array | string,\n  { prefix = AddressPrefix.Mainnet, type = AddressType.HashIdx, codeHashOrCodeHashIndex = '' }: AddressOptions = {},\n) => bech32.encode(prefix, bech32.toWords(toAddressPayload(args, type, codeHashOrCodeHashIndex)), MAX_BECH32_LIMIT)\n\n/**\n * @deprecated\n * @name fullPayloadToAddress\n * @description deprecated method to generate the address with payload in full version format. Use scriptToAddress instead.\n * @param {string} args, used as the identifier of an address.\n * @param {[string]} prefix, the prefix precedes the address, default to be ckb.\n * @param {[string]} type, used to indicate which format the address conforms to, default to be 0x02,\n *                       with hash type of Data or with hash type of Type.\n * @param {string} codeHash, the code hash used in the full version payload.\n */\nexport const fullPayloadToAddress = ({\n  args,\n  prefix,\n  type = AddressType.DataCodeHash,\n  codeHash,\n}: {\n  args: string\n  prefix?: AddressPrefix\n  type?: AddressType.DataCodeHash | AddressType.TypeCodeHash\n  codeHash: CKBComponents.Hash256\n}) => bech32Address(args, { prefix, type, codeHashOrCodeHashIndex: codeHash })\n\nexport const pubkeyToAddress = (pubkey: Uint8Array | string, options: AddressOptions = {}) => {\n  const publicKeyHash = blake160(pubkey)\n  return bech32Address(publicKeyHash, options)\n}\n\nconst isValidShortVersionPayload = (payload: Uint8Array, bech32Type?: Bech32Type) => {\n  const [type, index, ...data] = payload\n  if (bech32Type !== Bech32Type.Bech32) {\n    throw new AddressFormatTypeAndEncodeMethodNotMatchException(type, bech32Type)\n  }\n  /* eslint-disable indent */\n  switch (index) {\n    case 0: // secp256k1 + blake160\n    case 1: {\n      // secp256k1 + multisig\n      if (data.length !== 20) {\n        throw new AddressPayloadException(payload, 'short')\n      }\n      break\n    }\n    case 2: {\n      // anyone can pay\n      if (data.length === 20 || data.length === 22 || data.length === 24) {\n        break\n      }\n      throw new AddressPayloadException(payload, 'short')\n    }\n    default: {\n      throw new AddressPayloadException(payload, 'short')\n    }\n  }\n  /* eslint-enable indent */\n}\n\nconst isPayloadValid = (payload: Uint8Array, bech32Type: Bech32Type) => {\n  const type = payload[0]\n  const data = payload.slice(1)\n  /* eslint-disable indent */\n  switch (type) {\n    case +AddressType.HashIdx: {\n      isValidShortVersionPayload(payload, bech32Type)\n      break\n    }\n    case +AddressType.DataCodeHash:\n    case +AddressType.TypeCodeHash: {\n      if (bech32Type !== Bech32Type.Bech32) {\n        throw new AddressFormatTypeAndEncodeMethodNotMatchException(type, bech32Type)\n      }\n      if (data.length < 32) {\n        throw new AddressPayloadException(payload, 'full')\n      }\n      break\n    }\n    case +AddressType.FullVersion: {\n      if (bech32Type !== Bech32Type.Bech32m) {\n        throw new AddressFormatTypeAndEncodeMethodNotMatchException(type, bech32Type)\n      }\n      const codeHash = data.slice(0, 32)\n      if (codeHash.length < 32) {\n        throw new CodeHashException(bytesToHex(codeHash))\n      }\n\n      const hashType = parseInt(data[32].toString(), 16)\n      if (hashType > 2 && hashType !== 4) {\n        throw new HashTypeException(`0x${hashType.toString(16)}`)\n      }\n\n      break\n    }\n    default: {\n      throw new AddressPayloadException(payload)\n    }\n  }\n  /* eslint-enable indent */\n}\n\nexport declare interface ParseAddress {\n  (address: string): Uint8Array\n  (address: string, encode: 'binary'): Uint8Array\n  (address: string, encode: 'hex'): string\n  (address: string, encode: 'binary' | 'hex'): Uint8Array | string\n}\n/**\n * @return addressPayload, consists of type | params | publicKeyHash\n *         e.g. 0x | 01 | 00 | e2fa82e70b062c8644b80ad7ecf6e015e5f352f6\n */\nexport const parseAddress: ParseAddress = (address: string, encode: 'binary' | 'hex' = 'binary'): any => {\n  let bech32Type: Bech32Type | undefined\n  let payload: Uint8Array = new Uint8Array()\n  try {\n    const decoded = bech32.decode(address, MAX_BECH32_LIMIT)\n    bech32Type = Bech32Type.Bech32\n    payload = new Uint8Array(bech32.fromWords(new Uint8Array(decoded.words)))\n  } catch {\n    const decoded = bech32m.decode(address, MAX_BECH32_LIMIT)\n    bech32Type = Bech32Type.Bech32m\n    payload = new Uint8Array(bech32m.fromWords(new Uint8Array(decoded.words)))\n  }\n\n  try {\n    isPayloadValid(payload, bech32Type)\n  } catch (err: any) {\n    if (err instanceof AddressFormatTypeAndEncodeMethodNotMatchException) {\n      throw err\n    }\n    throw new AddressException(address, err.stack, err.type)\n  }\n  return encode === 'binary' ? payload : bytesToHex(payload)\n}\n\nexport const addressToScript = (address: string): CKBComponents.Script => {\n  const payload = parseAddress(address)\n  const type = payload[0]\n\n  switch (type) {\n    case +AddressType.FullVersion: {\n      const HASH_TYPE: Record<string, CKBComponents.ScriptHashType> = {\n        '00': 'data',\n        '01': 'type',\n        '02': 'data1',\n        '04': 'data2'\n      }\n      const p = bytesToHex(payload)\n\n      const codeHash = `0x${p.substring(4, 68)}`\n      const hashType = HASH_TYPE[p.substring(68, 70)]\n      const args = `0x${p.substring(70)}`\n      return { codeHash, hashType, args }\n    }\n    case +AddressType.HashIdx: {\n      const codeHashIndices = [\n        SECP256K1_BLAKE160,\n        SECP256K1_MULTISIG,\n        address.startsWith(AddressPrefix.Mainnet) ? ANYONE_CAN_PAY_MAINNET : ANYONE_CAN_PAY_TESTNET,\n      ]\n      const index = payload[1]\n      const args = payload.slice(2)\n      const script = codeHashIndices[index] ?? SECP256K1_BLAKE160\n      return {\n        codeHash: script.codeHash,\n        hashType: script.hashType,\n        args: bytesToHex(args),\n      }\n    }\n    case +AddressType.DataCodeHash:\n    case +AddressType.TypeCodeHash: {\n      const codeHashAndArgs = bytesToHex(payload.slice(1))\n      const hashType = type === +AddressType.DataCodeHash ? 'data' : 'type'\n      return {\n        codeHash: codeHashAndArgs.substring(0, 66),\n        hashType,\n        args: `0x${codeHashAndArgs.substring(66)}`,\n      }\n    }\n    default: {\n      throw new AddressFormatTypeException(type)\n    }\n  }\n}\n","export { bech32, bech32m } from 'bech32'\nexport { blake2b } from './blake2b'\nexport { blake160 } from './blake160'\n","/* eslint-disable no-param-reassign */\nimport {\n  OutLenTooSmallException,\n  OutLenTooLargeException,\n  KeyLenTooSmallException,\n  KeyLenTooLargeException,\n  OutTypeException,\n  SaltTypeException,\n  SaltLenException,\n  InputTypeException,\n  KeyTypeException,\n  PersonalTypeException,\n  PersonalLenException,\n} from '../exceptions'\n\nconst BYTES_MIN = 16\nconst BYTES_MAX = 64\n\nconst KEYBYTES_MIN = 16\nconst KEYBYTES_MAX = 64\n\nconst SALTBYTES = 16\nconst PERSONALBYTES = 16\n\nconst v = new Uint32Array(32)\nconst m = new Uint32Array(32)\n\n/**\n * @function ADD64AA\n * @description 64-bit unsigned addition, set vec[a, a + 1] += vec[b, b + 1]\n * @param {Uint32Array} vec\n * @param {number} a\n * @param {number} b\n */\nconst ADD64AA = (vec: Uint32Array, a: number, b: number) => {\n  const o0 = vec[a] + vec[b]\n  let o1 = vec[a + 1] + vec[b + 1]\n  if (o0 >= 0x100000000) {\n    o1++\n  }\n  vec[a] = o0\n  vec[a + 1] = o1\n}\n\n/**\n * @function ADD64AC\n * @description 64-bit unsigned addition, set vec[a, a + 1] += b, b0 is the low 32 bits of b and b1 is the high 32 bits\n * @param {Uint32Array} vec\n * @param {number} a\n * @param {number} b0\n * @param {number} b1\n */\nconst ADD64AC = (vec: Uint32Array, a: number, b0: number, b1: number) => {\n  let o0 = vec[a] + b0\n  if (b0 < 0) {\n    o0 += 0x100000000\n  }\n  let o1 = vec[a + 1] + b1\n  if (o0 >= 0x100000000) {\n    o1++\n  }\n  vec[a] = o0\n  vec[a + 1] = o1\n}\n\n// Little-endian byte access\nconst B2B_GET32 = (arr: Uint8Array, i: number) => {\n  return arr[i] ^ (arr[i + 1] << 8) ^ (arr[i + 2] << 16) ^ (arr[i + 3] << 24)\n}\n\n// G Mixing function\n// The ROTRs are inlined for speed\nconst B2B_G = (a: number, b: number, c: number, d: number, ix: number, iy: number) => {\n  const x0 = m[ix]\n  const x1 = m[ix + 1]\n  const y0 = m[iy]\n  const y1 = m[iy + 1]\n\n  ADD64AA(v, a, b) // v[a,a+1] += v[b,b+1] ... in JS we must store a uint64 as two uint32s\n  ADD64AC(v, a, x0, x1) // v[a, a+1] += x ... x0 is the low 32 bits of x, x1 is the high 32 bits\n\n  // v[d,d+1] = (v[d,d+1] xor v[a,a+1]) rotated to the right by 32 bits\n  let xor0 = v[d] ^ v[a]\n  let xor1 = v[d + 1] ^ v[a + 1]\n  v[d] = xor1\n  v[d + 1] = xor0\n\n  ADD64AA(v, c, d)\n\n  // v[b,b+1] = (v[b,b+1] xor v[c,c+1]) rotated right by 24 bits\n  xor0 = v[b] ^ v[c]\n  xor1 = v[b + 1] ^ v[c + 1]\n  v[b] = (xor0 >>> 24) ^ (xor1 << 8)\n  v[b + 1] = (xor1 >>> 24) ^ (xor0 << 8)\n\n  ADD64AA(v, a, b)\n  ADD64AC(v, a, y0, y1)\n\n  // v[d,d+1] = (v[d,d+1] xor v[a,a+1]) rotated right by 16 bits\n  xor0 = v[d] ^ v[a]\n  xor1 = v[d + 1] ^ v[a + 1]\n  v[d] = (xor0 >>> 16) ^ (xor1 << 16)\n  v[d + 1] = (xor1 >>> 16) ^ (xor0 << 16)\n\n  ADD64AA(v, c, d)\n\n  // v[b,b+1] = (v[b,b+1] xor v[c,c+1]) rotated right by 63 bits\n  xor0 = v[b] ^ v[c]\n  xor1 = v[b + 1] ^ v[c + 1]\n  v[b] = (xor1 >>> 31) ^ (xor0 << 1)\n  v[b + 1] = (xor0 >>> 31) ^ (xor1 << 1)\n}\n\n/* eslint-disable prettier/prettier */\n// Initialization Vector\nconst BLAKE2B_IV32 = new Uint32Array([\n  0xf3bcc908, 0x6a09e667, 0x84caa73b, 0xbb67ae85,\n  0xfe94f82b, 0x3c6ef372, 0x5f1d36f1, 0xa54ff53a,\n  0xade682d1, 0x510e527f, 0x2b3e6c1f, 0x9b05688c,\n  0xfb41bd6b, 0x1f83d9ab, 0x137e2179, 0x5be0cd19,\n])\n\nconst SIGMA8 = [\n  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n  14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3,\n  11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4,\n  7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8,\n  9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13,\n  2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9,\n  12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11,\n  13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10,\n  6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5,\n  10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0,\n  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n  14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3,\n]\n/* eslint-enable prettier/prettier */\n\n// These are offsets into a uint64 buffer.\n// Multiply them all by 2 to make them offsets into a uint32 buffer,\n// because this is JavaScript and we don't have uint64s\nconst SIGMA82 = new Uint8Array(\n  SIGMA8.map(x => {\n    return x * 2\n  }),\n)\n\nconst blake2bCompress = (ctx: Blake2b, last: boolean) => {\n  let i = 0\n\n  // init work variables\n  for (i = 0; i < 16; i++) {\n    v[i] = ctx.h[i]\n    v[i + 16] = BLAKE2B_IV32[i]\n  }\n\n  // low 64 bits of offset\n  v[24] ^= ctx.t\n  v[25] ^= ctx.t / 0x100000000\n  // high 64 bits not supported, offset may not be higher than 2**53-1\n\n  // last block flag set ?\n  if (last) {\n    v[28] = ~v[28]\n    v[29] = ~v[29]\n  }\n\n  // get little-endian words\n  for (i = 0; i < 32; i++) {\n    m[i] = B2B_GET32(ctx.b, 4 * i)\n  }\n\n  // twelve rounds of mixing\n  for (i = 0; i < 12; i++) {\n    B2B_G(0, 8, 16, 24, SIGMA82[i * 16 + 0], SIGMA82[i * 16 + 1])\n    B2B_G(2, 10, 18, 26, SIGMA82[i * 16 + 2], SIGMA82[i * 16 + 3])\n    B2B_G(4, 12, 20, 28, SIGMA82[i * 16 + 4], SIGMA82[i * 16 + 5])\n    B2B_G(6, 14, 22, 30, SIGMA82[i * 16 + 6], SIGMA82[i * 16 + 7])\n    B2B_G(0, 10, 20, 30, SIGMA82[i * 16 + 8], SIGMA82[i * 16 + 9])\n    B2B_G(2, 12, 22, 24, SIGMA82[i * 16 + 10], SIGMA82[i * 16 + 11])\n    B2B_G(4, 14, 16, 26, SIGMA82[i * 16 + 12], SIGMA82[i * 16 + 13])\n    B2B_G(6, 8, 18, 28, SIGMA82[i * 16 + 14], SIGMA82[i * 16 + 15])\n  }\n\n  for (i = 0; i < 16; i++) {\n    ctx.h[i] = ctx.h[i] ^ v[i] ^ v[i + 16]\n  }\n}\n\n/**\n * @function blake2bUpdate\n * @description updates a BLAKE2b streaming hash, requires hash context and Uint8Array\n */\nconst blake2bUpdate = (ctx: Blake2b, input: Uint8Array) => {\n  for (let i = 0; i < input.length; i++) {\n    // buffer full?\n    if (ctx.c === 128) {\n      ctx.t += ctx.c // add counters\n      blake2bCompress(ctx, false) // compress (not last)\n      ctx.c = 0 // counter to zero\n    }\n    ctx.b[ctx.c++] = +input[i]\n  }\n}\n\n// Completes a BLAKE2b streaming hash\n// Returns a Uint8Array containing the message digest\n/**\n * @function blake2bFinal\n * @description completes a BLAKE2b streaming hash, returns a Uint8Array containing the message digest\n */\nconst blake2bFinal = (ctx: Blake2b, out: Uint8Array) => {\n  ctx.t += ctx.c // mark last block offset\n\n  // fill up with zeros\n  while (ctx.c < 128) {\n    ctx.b[ctx.c++] = 0\n  }\n  blake2bCompress(ctx, true) // final block flag = 1\n\n  for (let i = 0; i < ctx.outlen; i++) {\n    out[i] = ctx.h[i >> 2] >> (8 * (i & 3))\n  }\n  return out\n}\n\nconst toHex = (n: number) => {\n  if (n < 16) return `0${n.toString(16)}`\n  return n.toString(16)\n}\n\nconst hexSlice = (buf: string | Uint8Array) => {\n  let str = ''\n  for (let i = 0; i < buf.length; i++) str += toHex(+buf[i])\n  return str\n}\n\n/* eslint-disable prettier/prettier */\n// reusable parameterBlock\nconst parameterBlock = new Uint8Array([\n  0, 0, 0, 0, //  0: outlen, keylen, fanout, depth 0,\n  0, 0, 0, 0, //  4: leaf length, sequential mode 0,\n  0, 0, 0, 0, //  8: node offset\n  0, 0, 0, 0, // 12: node offset\n  0, 0, 0, 0, // 16: node depth, inner length, rfu\n  0, 0, 0, 0, // 20: rfu\n  0, 0, 0, 0, // 24: rfu\n  0, 0, 0, 0, // 28: rfu\n  0, 0, 0, 0, // 32: salt\n  0, 0, 0, 0, // 36: salt\n  0, 0, 0, 0, // 40: salt\n  0, 0, 0, 0, // 44: salt\n  0, 0, 0, 0, // 48: personal\n  0, 0, 0, 0, // 52: personal\n  0, 0, 0, 0, // 56: personal\n  0, 0, 0, 0, // 60: personal\n])\n/* eslint-enable prettier/prettier */\n\nexport class Blake2b {\n  b: Uint8Array\n\n  h: Uint32Array\n\n  t: number\n\n  c: number\n\n  outlen: number\n\n  // Creates a BLAKE2b hashing context\n  // Requires an output length between 1 and 64 bytes\n  // Takes an optional Uint8Array key\n  constructor(outlen: number, key: Uint8Array | null, salt: Uint8Array | null, personal: Uint8Array | null) {\n    // zero out parameterBlock before usage\n    parameterBlock.fill(0)\n    // state, 'param block'\n\n    this.b = new Uint8Array(128)\n    this.h = new Uint32Array(16)\n    this.t = 0 // input count\n    this.c = 0 // pointer within buffer\n    this.outlen = outlen // output length in bytes\n\n    parameterBlock[0] = outlen\n    if (key) parameterBlock[1] = key.length\n    parameterBlock[2] = 1 // fanout\n    parameterBlock[3] = 1 // depth\n\n    if (salt) parameterBlock.set(salt, 32)\n    if (personal) parameterBlock.set(personal, 48)\n\n    // initialize hash state\n    for (let i = 0; i < 16; i++) {\n      this.h[i] = BLAKE2B_IV32[i] ^ B2B_GET32(parameterBlock, i * 4)\n    }\n\n    // key the hash, if applicable\n    if (key) {\n      blake2bUpdate(this, key)\n      // at the end\n      this.c = 128\n    }\n  }\n\n  update = (input: Uint8Array) => {\n    if (!(input instanceof Uint8Array)) {\n      throw new InputTypeException()\n    }\n    blake2bUpdate(this, input)\n    return this\n  }\n\n  digest = (out: 'binary' | 'hex') => {\n    const buf = !out || out === 'binary' || out === 'hex' ? new Uint8Array(this.outlen) : out\n    if (!(buf instanceof Uint8Array)) {\n      throw new OutTypeException()\n    }\n    if (buf.length < this.outlen) {\n      throw new Error('out must have at least outlen bytes of space')\n    }\n    blake2bFinal(this, buf)\n    if (out === 'hex') return hexSlice(buf)\n    return buf\n  }\n\n  final = this.digest\n}\n\nexport const blake2b = (\n  outlen: number,\n  key: Uint8Array | null,\n  salt: Uint8Array | null,\n  personal: Uint8Array | null,\n  noAssert?: boolean,\n) => {\n  if (noAssert !== true) {\n    if (outlen < BYTES_MIN) {\n      throw new OutLenTooSmallException(outlen, BYTES_MIN)\n    }\n    if (outlen > BYTES_MAX) {\n      throw new OutLenTooLargeException(outlen, BYTES_MAX)\n    }\n    if (key !== null) {\n      if (!(key instanceof Uint8Array)) {\n        throw new KeyTypeException()\n      }\n      if (key.length < KEYBYTES_MIN) {\n        throw new KeyLenTooSmallException(key.length, KEYBYTES_MIN)\n      }\n      if (key.length > KEYBYTES_MAX) {\n        throw new KeyLenTooLargeException(key.length, KEYBYTES_MAX)\n      }\n    }\n    if (salt !== null) {\n      if (!(salt instanceof Uint8Array)) {\n        throw new SaltTypeException()\n      }\n      if (salt.length !== SALTBYTES) {\n        throw new SaltLenException(salt.length, SALTBYTES)\n      }\n    }\n    if (personal !== null) {\n      if (!(personal instanceof Uint8Array)) {\n        throw new PersonalTypeException()\n      }\n      if (personal.length !== PERSONALBYTES) {\n        throw new PersonalLenException(personal.length, PERSONALBYTES)\n      }\n    }\n  }\n\n  return new Blake2b(outlen, key, salt, personal)\n}\n","import { CKBComponents } from \"../types\"\n\n/**\n * Encoded string 'ckb-default-hash'\n *\n * @constant\n * @type {bytes}\n */\nexport const PERSONAL = new Uint8Array([99, 107, 98, 45, 100, 101, 102, 97, 117, 108, 116, 45, 104, 97, 115, 104])\n\nexport const EMPTY_WITNESS_ARGS: CKBComponents.WitnessArgs = {\n  lock: '',\n  inputType: '',\n  outputType: '',\n}\n\nexport const EMPTY_SECP_SIG = `0x${'0'.repeat(130)}`\n","import { blake2b } from './blake2b'\nimport { hexToBytes } from '../convertors'\nimport { PERSONAL } from '../const'\n\nexport declare interface Blake160 {\n  (data: Uint8Array | string): Uint8Array\n  (data: Uint8Array | string, encode: 'binary'): Uint8Array\n  (data: Uint8Array | string, encode: 'hex'): string\n  (data: Uint8Array | string, encode: 'binary' | 'hex'): Uint8Array | string\n}\n\nexport const blake160: Blake160 = (data: Uint8Array | string, encode: 'binary' | 'hex' = 'binary'): any => {\n  const formattedData = typeof data === 'string' ? hexToBytes(data) : data\n  const s = blake2b(32, null, null, PERSONAL)\n  s.update(formattedData)\n  return s.digest(encode).slice(0, encode === 'binary' ? 20 : 40)\n}\n","import { hexToBytes, bytesToHex, toUint32Le } from '../convertors'\n\nexport const offsetSize = 4 // 4 bytes\n\nexport const fullLengthSize = 4 // 4 bytes\n\nexport const getOffsets = (elmLengths: number[]) => {\n  const headerLength = fullLengthSize + offsetSize * elmLengths.length\n  const offsets = [headerLength]\n  elmLengths.forEach((_, idx: number) => {\n    if (idx) {\n      offsets.push(offsets[offsets.length - 1] + elmLengths[idx - 1])\n    }\n  })\n  return offsets\n}\n\n/**\n * @name serializeArray\n * @description The array is a fixed-size type: it has a fixed-size type and a fixed length.\n *              The size of an array is the size of inner type times the length.\n *              Serialize an array only need to serialize all items in it. No extra cost for array itself.\n */\nexport const serializeArray = (array: string | Uint8Array) => {\n  if (typeof array !== 'string' && !Array.isArray(array)) {\n    throw new TypeError('The array to be serialized should by type of string or bytes')\n  }\n  const bytes = typeof array === 'string' ? hexToBytes(array) : array\n  return bytesToHex(bytes)\n}\n\n/**\n * @name serializeStruct\n * @type Struct is a fixed-size type: all fields in struct is fixed-size,\n *              and it has a fixed quantity of fields.\n * @description The size of a struct is the sum of all fields' size.\n *              Serialize a struct only need to serialize all fields in it.\n *              No extra cost for struct itself.\n *              Fields in a struct are stored in the order they are declared.\n */\nexport const serializeStruct = (struct: Map<string, string | Uint8Array>) => {\n  let res = ''\n  struct.forEach(value => {\n    res += serializeArray(value).slice(2)\n  })\n  return `0x${res}`\n}\n\n/**\n * @name serializeFixVec\n * @type FixVec, a fixed-size vector is a vector whose items have a fixed size\n * @tutorial There are two steps of serializing a serializeFixVec\n *           1. Serialize the length as a 32 bit unsigned integer in little-endian\n *           2. Serialize all items in it\n */\nexport const serializeFixVec = (fixVec: string | (string | Uint8Array)[]): string => {\n  if (typeof fixVec !== 'string' && !Array.isArray(fixVec)) {\n    throw new TypeError('The fixed vector to be serialized should be a string or an array of bytes')\n  }\n  const vec = typeof fixVec === 'string' ? [...hexToBytes(fixVec)].map(b => `0x${b.toString(16)}`) : fixVec\n  const serializedItemVec = vec.map(item => serializeArray(item).slice(2))\n  const header = toUint32Le(`0x${serializedItemVec.length.toString(16)}`).slice(2)\n  return `0x${header}${serializedItemVec.join('')}`\n}\n\n/**\n * @name serializeDynVec\n * @type DynVec, a dynamic-size vector is a vector whose items have a dynamic size\n * @tutorial There are three steps of serializing a dynvec\n *           1. Serialize the full size in bytes as a 32 bit unsigned integer in little-endian\n *           2. Serialize all offset of the items as 32 bit unsigned integer in little-endian\n *           3. Serialize all items in it\n */\nexport const serializeDynVec = (dynVec: (string | Uint8Array)[]) => {\n   if (!Array.isArray(dynVec)) {\n     throw new TypeError('The dynamic vector to be serialized should be an array of bytes')\n   }\n   const serializedItemVec = dynVec.map(item => serializeArray(item).slice(2))\n   const body = serializedItemVec.join('')\n   let offsets = ''\n   if (serializedItemVec.length) {\n     offsets = getOffsets(serializedItemVec.map(item => item.length / 2))\n       .map(offset => toUint32Le(`0x${offset.toString(16)}`).slice(2))\n       .join('')\n   }\n   const headerLength = fullLengthSize + offsetSize * serializedItemVec.length\n   const fullLength = toUint32Le(`0x${(headerLength + body.length / 2).toString(16)}`).slice(2)\n   return `0x${fullLength}${offsets}${body}`\n}\n\n/**\n * @name serializeTable\n * @type Table, the table is a dynamic-size type, It can be considered as a dynvec but the length is fixed.\n */\nexport const serializeTable = (table: Map<string, string | Uint8Array>) => {\n  const bodyElms: string[] = []\n  table.forEach(value => {\n    bodyElms.push(serializeArray(value).slice(2))\n  })\n  const body = bodyElms.join('')\n  const headerLength = fullLengthSize + offsetSize * table.size\n  const fullLength = toUint32Le(`0x${(headerLength + body.length / 2).toString(16)}`).slice(2)\n  const offsets = getOffsets(bodyElms.map(arg => arg.length / 2))\n    .map(offset => toUint32Le(`0x${offset.toString(16)}`).slice(2))\n    .join('')\n  return `0x${fullLength}${offsets}${body}`\n}\n\n/**\n * @name serializeOption\n * @type Option is a dynamic-size type\n * @tutorial Serialize an option depends on whether it is empty or not\n *           1. if it's empty, there is zero bytes(the size is 0)\n *           2. if it's not empty, just serialize the inner item(the size is same as the inner item's size)\n */\nexport const serializeOption = (innerItem?: string) => (!innerItem ? '0x' : innerItem)\n","import { serializeArray, serializeTable, serializeFixVec } from './basic'\nimport { ParameterRequiredException } from '../exceptions'\nimport { CKBComponents } from '../../types'\n\nexport const serializeCodeHash = (codeHash: CKBComponents.Hash256) => serializeArray(codeHash)\n\nexport const serializeHashType = (hashType: CKBComponents.ScriptHashType) => {\n  if (hashType === 'data') return '0x00'\n  if (hashType === 'type') return '0x01'\n  if (hashType === 'data1') return '0x02'\n  if (hashType === 'data2') return '0x04'\n  throw new TypeError(\"Hash type must be either of 'data' or 'type'\")\n}\n\nexport const serializeArgs = (args: string) => serializeFixVec(args)\n\nexport const serializeScript = (script: CKBComponents.Script) => {\n  if (!script) throw new ParameterRequiredException('Script')\n  const { codeHash = '', hashType, args = '' } = script\n  const serializedCodeHash = serializeCodeHash(codeHash)\n  const serializedHashType = serializeHashType(hashType)\n  const serializedArgs = serializeArgs(args)\n  const table = new Map([\n    ['codeHash', serializedCodeHash],\n    ['hashType', serializedHashType],\n    ['args', serializedArgs],\n  ])\n  return serializeTable(table)\n}\n","import { serializeScript } from './script'\nimport { toUint32Le, toUint64Le } from '../convertors'\nimport {\n  serializeArray,\n  serializeStruct,\n  serializeTable,\n  serializeDynVec,\n  serializeFixVec,\n  serializeOption,\n} from './basic'\nimport { CKBComponents } from '../../types'\n\nexport const serializeVersion = (version: CKBComponents.Version) => toUint32Le(version)\n\nexport const serializeOutPoint = (outPoint: CKBComponents.OutPoint | null) => {\n  if (!outPoint) return ''\n  const struct = new Map<string, string>([\n    ['txHash', outPoint.txHash],\n    ['index', toUint32Le(outPoint.index)],\n  ])\n  return serializeStruct(struct)\n}\n\nexport const serializeDepType = (type: CKBComponents.DepType) => {\n  if (type === 'code') return '0x00'\n  if (type === 'depGroup') return '0x01'\n  throw new TypeError(\"Dep type must be either of 'code' or 'depGroup'\")\n}\n\nexport const serializeCellDep = (dep: CKBComponents.CellDep) => {\n  const serializedOutPoint = serializeOutPoint(dep.outPoint)\n  const serializedDepType = serializeDepType(dep.depType)\n  const struct = new Map<string, string>([\n    ['outPoint', serializedOutPoint],\n    ['depType', serializedDepType],\n  ])\n  return serializeStruct(struct)\n}\n\nexport const serializeCellDeps = (cellDeps: CKBComponents.CellDep[]) => {\n  const serializedCellDepList = cellDeps.map(dep => serializeCellDep(dep))\n  return serializeFixVec(serializedCellDepList)\n}\n\nexport const serializeHeaderDeps = (deps: CKBComponents.Hash256[]) => {\n  const serializedHeaderDepList = deps.map(dep => serializeArray(dep))\n  return serializeFixVec(serializedHeaderDepList)\n}\n\nexport const serializeInput = (input: CKBComponents.CellInput) => {\n  const serializedOutPoint = serializeOutPoint(input.previousOutput)\n  const serializedSince = toUint64Le(input.since)\n  const struct = new Map([\n    ['since', serializedSince],\n    ['previousOutput', serializedOutPoint],\n  ])\n  return serializeStruct(struct)\n}\n\nexport const serializeInputs = (inputs: CKBComponents.CellInput[]) => {\n  const serializedInputList = inputs.map(input => serializeInput(input))\n  return serializeFixVec(serializedInputList)\n}\n\nexport const serializeOutput = (output: CKBComponents.CellOutput) => {\n  const serializedCapacity = toUint64Le(output.capacity)\n  const serializedLockScript = serializeScript(output.lock)\n  const serialiedTypeScript = output.type ? serializeScript(output.type) : ''\n  const table = new Map([\n    ['capacity', serializedCapacity],\n    ['lock', serializedLockScript],\n    ['type', serialiedTypeScript],\n  ])\n  return serializeTable(table)\n}\n\nexport const serializeOutputs = (outputs: CKBComponents.CellOutput[]) => {\n  const serializedOutputList = outputs.map(output => serializeOutput(output))\n  return serializeDynVec(serializedOutputList)\n}\n\nexport const serializeOutputsData = (outputsData: CKBComponents.Hash[]) => {\n  const serializedOutputsDatumList = outputsData.map(datum => serializeFixVec(datum))\n  return serializeDynVec(serializedOutputsDatumList)\n}\n\nexport const serializeWitnessArgs = (witnessArgs: CKBComponents.WitnessArgs) => {\n  const { lock, inputType, outputType } = witnessArgs\n  const table = new Map([\n    ['lock', serializeOption(lock) === '0x' ? '0x' : serializeFixVec(lock!)],\n    ['inputType', serializeOption(inputType) === '0x' ? '0x' : serializeFixVec(inputType!)],\n    ['outputType', serializeOption(outputType) === '0x' ? '0x' : serializeFixVec(outputType!)],\n  ])\n  return serializeTable(table)\n}\n\nexport const serializeWitnesses = (witnesses: CKBComponents.Witness[]) => {\n  const serializedWitnessList = witnesses.map(witness => serializeFixVec(witness))\n  return serializeDynVec(serializedWitnessList)\n}\n\nexport const serializeRawTransaction = (\n  rawTransaction: Pick<\n    CKBComponents.RawTransaction,\n    'version' | 'cellDeps' | 'headerDeps' | 'inputs' | 'outputs' | 'outputsData'\n  >,\n) => {\n  const serializedVersion = serializeVersion(rawTransaction.version)\n  const serializedCellDeps = serializeCellDeps(rawTransaction.cellDeps)\n  const serializedHeaderDeps = serializeHeaderDeps(rawTransaction.headerDeps)\n  const serializedInputs = serializeInputs(rawTransaction.inputs)\n  const serializedOutputs = serializeOutputs(rawTransaction.outputs)\n  const serializedOutputsData = serializeOutputsData(rawTransaction.outputsData)\n\n  const table = new Map([\n    ['version', serializedVersion],\n    ['cellDeps', serializedCellDeps],\n    ['headerDeps', serializedHeaderDeps],\n    ['inputs', serializedInputs],\n    ['outputs', serializedOutputs],\n    ['outputsData', serializedOutputsData],\n  ])\n\n  return serializeTable(table)\n}\n\nexport const serializeTransaction = (rawTransaction: CKBComponents.RawTransaction) => {\n  const serializedRawTransaction = serializeRawTransaction(rawTransaction)\n  const serializedWitnesses = serializeWitnesses(rawTransaction.witnesses || [])\n\n  const table = new Map([\n    ['raw', serializedRawTransaction],\n    ['witnesses', serializedWitnesses],\n  ])\n  return serializeTable(table)\n}\n","import { CKBComponents } from \"../types\"\n\nconst codeHashOccupied = 32\nconst hashTypeOccupied = 1\n\nexport const scriptOccupied = (script: CKBComponents.Script) => {\n  return script.args.slice(2).length / 2 + codeHashOccupied + hashTypeOccupied\n}\n\nexport const cellOccupied = (cell: CKBComponents.CellOutput) => {\n  return 8 + scriptOccupied(cell.lock) + (cell.type ? scriptOccupied(cell.type) : 0)\n}\n","import JSBI from 'jsbi'\nimport { assertToBeHexString } from './validators'\nimport { CKBComponents } from '../types'\n\nexport interface EpochInfo {\n  length: string\n  index: string\n  number: string\n}\n\nexport const serializeEpoch = ({ length, index, number }: EpochInfo): string => {\n  assertToBeHexString(length)\n  assertToBeHexString(index)\n  assertToBeHexString(number)\n\n  const epochSince = JSBI.add(\n    JSBI.add(\n      JSBI.add(\n        JSBI.leftShift(JSBI.BigInt(0x20), JSBI.BigInt(56)),\n        JSBI.leftShift(JSBI.BigInt(length), JSBI.BigInt(40)),\n      ),\n      JSBI.leftShift(JSBI.BigInt(index), JSBI.BigInt(24)),\n    ),\n    JSBI.BigInt(number),\n  )\n\n  return `0x${epochSince.toString(16)}`\n}\n\nexport const parseEpoch = (epoch: CKBComponents.EpochInHeader) => ({\n  length: `0x${JSBI.bitwiseAnd(\n    JSBI.signedRightShift(JSBI.BigInt(epoch), JSBI.BigInt(40)),\n    JSBI.BigInt(0xffff),\n  ).toString(16)}`,\n  index: `0x${JSBI.bitwiseAnd(JSBI.signedRightShift(JSBI.BigInt(epoch), JSBI.BigInt(24)), JSBI.BigInt(0xffff)).toString(\n    16,\n  )}`,\n  number: `0x${JSBI.bitwiseAnd(JSBI.BigInt(epoch), JSBI.BigInt(0xffffff)).toString(16)}`,\n})\n\n/**\n * @memberof Utils\n * @function getWithdrawEpoch\n * @description Calculate the minimum epoch to withdraw the deposit by deposit epoch and withdrawing epoch\n * @param {string} depositEpoch Epoch when deposit happens\n * @param {string} withdrawingEpoch Epoch when withdrawing happens\n */\nexport const getWithdrawEpoch = (depositEpoch: string, withdrawingEpoch: string) => {\n  const EPOCHS_PER_WITHDRAW_CYCLE = 180\n  const depositEpochInfo = parseEpoch(depositEpoch)\n  const withdrawingEpochInfo = parseEpoch(withdrawingEpoch)\n\n  let depositedEpochCount = +withdrawingEpochInfo.number - +depositEpochInfo.number\n\n  if (+withdrawingEpochInfo.index * +depositEpochInfo.length > +depositEpochInfo.index * +withdrawingEpochInfo.length) {\n    depositedEpochCount += 1\n  }\n\n  const minEpockCountToLock =\n    depositedEpochCount <= EPOCHS_PER_WITHDRAW_CYCLE\n      ? EPOCHS_PER_WITHDRAW_CYCLE\n      : (Math.floor((depositedEpochCount - 1) / EPOCHS_PER_WITHDRAW_CYCLE) + 1) * EPOCHS_PER_WITHDRAW_CYCLE\n\n  return serializeEpoch({\n    index: depositEpochInfo.index,\n    length: depositEpochInfo.length,\n    number: `0x${(+depositEpochInfo.number + minEpockCountToLock).toString(16)}`,\n  })\n}\n","import { CKBComponents } from '../types'\nimport { serializeWitnessArgs, serializeTransaction } from './serialization/transaction'\n\n/**\n * @name getTransactionSize\n * @description return the size of a transaction cost in a block, 4 bytes more than the serialized transaction.\n * @param {Object} transaction - Raw transaction\n * @returns {String} Virtual size of a transaction in a block\n */\nexport const getTransactionSize = (transaction: CKBComponents.RawTransactionToSign) => {\n  const tx = {\n    ...transaction,\n    witnesses: transaction.witnesses.map(wit => (typeof wit === 'string' ? wit : serializeWitnessArgs(wit))),\n  }\n  // extra 4 bytes size due to the cost of serialized tx in a block\n  const VIRTUAL_COST = 4\n  const serializedTransaction = serializeTransaction(tx)\n  return serializedTransaction.slice(2).length / 2 + VIRTUAL_COST\n}\n","import JSBI from 'jsbi'\nimport { calculateTransactionFee } from '../calculateTransactionFee'\nimport { getTransactionSize } from '../sizes'\nimport { ReconciliationException } from '../exceptions'\nimport { CKBComponents } from '../../types'\n\ndeclare namespace Reconciliation {\n  type Cell = { capacity: string; outPoint: CKBComponents.OutPoint }\n  interface ExtraInputsParams {\n    tx: CKBComponents.RawTransactionToSign\n    feeRate: string | bigint\n    changeThreshold: string | bigint\n    cells: Array<Cell>\n    extraCount: number\n  }\n}\n\nexport const extraInputs = (params: Reconciliation.ExtraInputsParams): CKBComponents.RawTransactionToSign => {\n  const changeThreshold = JSBI.BigInt(`${params.changeThreshold}`)\n\n  const feeRate = JSBI.BigInt(`${params.feeRate}`)\n  const currentChangeOutput = params.tx.outputs[params.tx.outputs.length - 1]\n  const currentChange = JSBI.BigInt(currentChangeOutput.capacity)\n\n  const fee = JSBI.BigInt(\n    calculateTransactionFee(`0x${getTransactionSize(params.tx).toString(16)}`, `0x${feeRate.toString(16)}`),\n  )\n  const lack = JSBI.subtract(JSBI.add(fee, changeThreshold), currentChange)\n\n  if (JSBI.LE(lack, JSBI.BigInt(0))) {\n    return {\n      ...params.tx,\n      outputs: [\n        ...params.tx.outputs.slice(0, -1),\n        {\n          ...currentChangeOutput,\n          capacity: `0x${JSBI.subtract(currentChange, fee).toString(16)}`,\n        },\n      ],\n    }\n  }\n\n  params.cells.sort((c1, c2) => +JSBI.subtract(JSBI.BigInt(c1.capacity), JSBI.BigInt(c2.capacity)))\n\n  const SIZE_PER_INPUT = JSBI.BigInt(44)\n  const FEE_PER_INPUT = JSBI.divide(JSBI.multiply(SIZE_PER_INPUT, feeRate), JSBI.BigInt(1000))\n\n  for (let i = 1; i <= Math.min(params.extraCount, params.cells.length); i++) {\n    const extraCost = JSBI.multiply(JSBI.BigInt(i), FEE_PER_INPUT)\n    const totalLack = JSBI.add(lack, extraCost)\n    const extraCapacity = params.cells\n      .slice(0, i)\n      .reduce((sum, c) => JSBI.add(sum, JSBI.BigInt(c.capacity)), JSBI.BigInt(0))\n    if (JSBI.GE(extraCapacity, totalLack)) {\n      const inputs = [\n        ...params.tx.inputs,\n        ...params.cells.slice(0, i).map(c => ({\n          previousOutput: c.outPoint,\n          since: '0x0',\n        })),\n      ]\n      const change = JSBI.add(changeThreshold, JSBI.subtract(extraCapacity, totalLack))\n      const changeOutput = { ...currentChangeOutput, capacity: `0x${change.toString(16)}` }\n      const outputs = [...params.tx.outputs.slice(0, -1), changeOutput]\n      const tx: CKBComponents.RawTransactionToSign = { ...params.tx, inputs, outputs }\n      return tx\n    }\n  }\n  throw new ReconciliationException()\n}\n","import JSBI from 'jsbi'\nimport { assertToBeHexStringOrBigint } from './validators'\n\n/**\n * @function calculateTransactionFee\n * @description calculate the transaction fee by transaction size and fee rate\n * @param {string | bigint} transactionSize, the byte size of transaction\n * @param {string | bigint} feeRate, the fee rate with unit of shannons/KB\n * @returns {string} transactionFee\n */\nexport const calculateTransactionFee = (transactionSize: string | bigint, feeRate: string | bigint): string => {\n  assertToBeHexStringOrBigint(transactionSize)\n  assertToBeHexStringOrBigint(feeRate)\n  const ratio = JSBI.BigInt(1000)\n  const base = JSBI.multiply(JSBI.BigInt(`${transactionSize}`), JSBI.BigInt(`${feeRate}`))\n  const fee = JSBI.divide(base, ratio)\n  if (JSBI.lessThan(JSBI.multiply(fee, ratio), base)) {\n    return `0x${JSBI.add(fee, JSBI.BigInt(1)).toString(16)}`\n  }\n  return `0x${fee.toString(16)}`\n}\n","import { ErrorCode } from '../../utils/exceptions'\n\nexport class PageSizeTooLargeException extends RangeError {\n  code = ErrorCode.ParameterInvalid\n\n  constructor(pageSize: bigint | string, maxSize: number) {\n    super(`Expect page size to be at most ${maxSize}, but ${pageSize} received`)\n  }\n}\n\nexport class PageSizeTooSmallException extends RangeError {\n  code = ErrorCode.ParameterInvalid\n\n  constructor(pageSize: bigint | string, minSize: number) {\n    super(`Expect page size to be at least ${minSize}, but ${pageSize} received`)\n  }\n}\n\nexport class OutputsValidatorTypeException extends TypeError {\n  code = ErrorCode.ParameterInvalid\n\n  constructor() {\n    super(`Expect outputs validator to be 'default' or 'passthrough'`)\n  }\n}\n\nexport class BigintOrHexStringTypeException extends TypeError {\n  code = ErrorCode.ParameterInvalid\n\n  constructor(value: any) {\n    super(`Expect number to be bigint or hex string, but ${value} received`)\n  }\n}\n\nexport class StringHashTypeException extends TypeError {\n  code = ErrorCode.ParameterInvalid\n\n  constructor(hash: any) {\n    super(`Expect hash to be string, but ${hash} received`)\n  }\n}\n","import { ErrorCode } from './ErrorCode'\n\nexport class IdNotMatchException extends Error {\n  code = ErrorCode.IdNotMatch\n\n  constructor(requestId: number, responseId: number) {\n    super(`Expect json rpc id to be ${requestId}, but ${responseId} received`)\n  }\n}\n\nexport class ResponseException extends Error {\n  code = ErrorCode.ResponseMessage\n}\n","import { ErrorCode } from './ErrorCode'\nimport { IdNotMatchException } from './rpc'\n\nconst ERROR_LABEL = 'Batch Request'\n\nexport class MethodInBatchNotFoundException extends Error {\n  code = ErrorCode.MethodNotFound\n\n  constructor(name: string) {\n    super(`[${ERROR_LABEL}]: Method ${name} is not found`)\n  }\n}\n\nexport class PayloadInBatchException extends Error {\n  code = ErrorCode.PayloadMessage\n\n  index: number | undefined\n\n  constructor(index: number, message: string) {\n    super(`[${ERROR_LABEL} ${index}]: ${message}`)\n    this.index = index\n  }\n}\n\nexport class IdNotMatchedInBatchException extends IdNotMatchException {\n  index: number | undefined\n\n  constructor(index: number, requestId: number, responseId: number) {\n    super(requestId, responseId)\n    this.message = `[${ERROR_LABEL} ${index}]: ${this.message}`\n    this.index = index\n  }\n}\n","import { CKBComponents } from '../types/blockchain'\nimport { RPC } from '../types/rpc'\nimport { JSBI } from '../utils'\nimport {\n  PageSizeTooLargeException,\n  PageSizeTooSmallException,\n  OutputsValidatorTypeException,\n  BigintOrHexStringTypeException,\n  StringHashTypeException,\n  HexStringWithout0xException,\n} from './exceptions'\n\n/* eslint-disable camelcase */\nconst formatter = {\n  toOptional: (format?: Function) => (arg: any) => {\n    if (!format || arg === undefined || arg === null) {\n      return arg\n    }\n    return format(arg)\n  },\n  toArray: (format?: (args: any) => any) => (arg: any) => {\n    if (typeof format !== 'function' || !Array.isArray(arg)) {\n      return arg\n    }\n    return arg.map(format)\n  },\n  toHash: (hash: string): RPC.Hash256 => {\n    if (typeof hash !== 'string') {\n      throw new StringHashTypeException(hash)\n    }\n    return hash.startsWith('0x') ? hash : `0x${hash}`\n  },\n  toNumber: (number: CKBComponents.Number | bigint): RPC.Number => {\n    if (typeof number === 'bigint') {\n      // @ts-ignore\n      return `0x${number.toString(16)}`\n    }\n    if (typeof number !== 'string') {\n      throw new BigintOrHexStringTypeException(number)\n    }\n    if (!number.startsWith('0x')) {\n      throw new HexStringWithout0xException(number)\n    }\n    return number\n  },\n  toScript: (script: CKBComponents.Script): RPC.Script => {\n    const { codeHash, hashType: hash_type, ...rest } = script\n    return {\n      code_hash: formatter.toHash(codeHash),\n      hash_type,\n      ...rest,\n    }\n  },\n  toOutPoint: (outPoint: CKBComponents.OutPoint | null): RPC.OutPoint | null => {\n    if (!outPoint) return outPoint\n    const { txHash, index, ...rest } = outPoint\n    return {\n      tx_hash: formatter.toHash(txHash),\n      index: formatter.toNumber(index),\n      ...rest,\n    }\n  },\n  toInput: (input: CKBComponents.CellInput): RPC.CellInput => {\n    if (!input) return input\n    const { previousOutput, since, ...rest } = input\n    return {\n      previous_output: formatter.toOutPoint(previousOutput),\n      since: formatter.toNumber(since),\n      ...rest,\n    }\n  },\n  toOutput: (output: CKBComponents.CellOutput): RPC.CellOutput => {\n    if (!output) return output\n    const { capacity, lock, type = null, ...rest } = output\n    return {\n      capacity: formatter.toNumber(capacity),\n      lock: formatter.toScript(lock),\n      type: type ? formatter.toScript(type) : type,\n      ...rest,\n    }\n  },\n  toDepType: (type: CKBComponents.DepType) => {\n    if (type === 'depGroup') {\n      return 'dep_group'\n    }\n    return type\n  },\n  toCellDep: (cellDep: CKBComponents.CellDep): RPC.CellDep => {\n    if (!cellDep) return cellDep\n    const { outPoint = null, depType = 'code', ...rest } = cellDep\n    return {\n      out_point: formatter.toOutPoint(outPoint),\n      dep_type: formatter.toDepType(depType),\n      ...rest,\n    }\n  },\n  toRawTransaction: (transaction: CKBComponents.RawTransaction): RPC.RawTransaction => {\n    if (!transaction) return transaction\n    const {\n      version,\n      cellDeps = [],\n      inputs = [],\n      outputs = [],\n      outputsData: outputs_data = [],\n      headerDeps: header_deps = [],\n      ...rest\n    } = transaction\n    const formattedInputs = inputs.map(input => formatter.toInput(input))\n    const formattedOutputs = outputs.map(output => formatter.toOutput(output))\n    const formattedCellDeps = cellDeps.map(cellDep => formatter.toCellDep(cellDep))\n    const tx = {\n      version: formatter.toNumber(version),\n      cell_deps: formattedCellDeps,\n      inputs: formattedInputs,\n      outputs: formattedOutputs,\n      outputs_data,\n      header_deps,\n      ...rest,\n    }\n    return tx\n  },\n  toPageNumber: (pageNo: string | bigint = '0x1') => formatter.toNumber(pageNo),\n  toPageSize: (pageSize: string | bigint = '0x32') => {\n    const size = JSBI.BigInt(`${pageSize}`)\n    const MAX_SIZE = 50\n    const MIN_SIZE = 0\n    if (JSBI.greaterThan(size, JSBI.BigInt(MAX_SIZE))) throw new PageSizeTooLargeException(pageSize, MAX_SIZE)\n    if (JSBI.lessThan(size, JSBI.BigInt(MIN_SIZE))) throw new PageSizeTooSmallException(pageSize, MIN_SIZE)\n    return formatter.toNumber(`0x${size.toString(16)}`)\n  },\n  toReverseOrder: (reverse: boolean = false) => !!reverse,\n  toOutputsValidator: (outputsValidator: CKBComponents.OutputsValidator) => {\n    if (!outputsValidator) return undefined\n    const VALIDATORS = ['default', 'passthrough']\n    if (VALIDATORS.indexOf(outputsValidator) > -1) {\n      return outputsValidator\n    }\n    throw new OutputsValidatorTypeException()\n  },\n  toBoolean: (value: boolean) => {\n    return !!value\n  },\n  toTransactionProof: (proof: CKBComponents.TransactionProof): RPC.TransactionProof => {\n    if (!proof) return proof\n    const { blockHash: block_hash, witnessesRoot: witnesses_root, ...rest } = proof\n    return {\n      block_hash,\n      witnesses_root,\n      ...rest,\n    }\n  },\n}\n\nexport default formatter\n/* eslint-enable camelcase */\n","import { CKBComponents, RPC } from \"../types\"\n\nconst isTxPoolIds = (rawTxPool: RPC.RawTxPool): rawTxPool is RPC.TxPoolIds => {\n  return Array.isArray(rawTxPool.pending)\n}\n\n\n/* eslint-disable camelcase */\nconst toNumber = (number: RPC.BlockNumber): CKBComponents.BlockNumber => number.toString()\nconst toHash = (hash: RPC.Hash256): CKBComponents.Hash256 => hash\nconst toHeader = (header: RPC.Header): CKBComponents.BlockHeader => {\n  if (!header) return header\n  const {\n    compact_target: compactTarget,\n    transactions_root: transactionsRoot,\n    proposals_hash: proposalsHash,\n    extra_hash: extraHash,\n    parent_hash: parentHash,\n    ...rest\n  } = header\n  return {\n    compactTarget,\n    parentHash,\n    transactionsRoot,\n    proposalsHash,\n    extraHash,\n    ...rest,\n  }\n}\nconst toScript = (script: RPC.Script): CKBComponents.Script => {\n  if (!script) return script\n  const { code_hash: codeHash, hash_type: hashType, ...rest } = script\n  return {\n    codeHash,\n    hashType,\n    ...rest,\n  }\n}\nconst toInput = (input: RPC.CellInput): CKBComponents.CellInput => {\n  if (!input) return input\n  const { previous_output: previousOutput, ...rest } = input\n  return {\n    previousOutput: previousOutput ? toOutPoint(previousOutput) : previousOutput,\n    ...rest,\n  }\n}\nconst toOutput = (output: RPC.CellOutput): CKBComponents.CellOutput => {\n  if (!output) return output\n  const { lock, type, ...rest } = output\n  return {\n    lock: toScript(lock),\n    type: type ? toScript(type) : type,\n    ...rest,\n  }\n}\nconst toOutPoint = (outPoint: RPC.OutPoint | null): CKBComponents.OutPoint | null => {\n  if (!outPoint) return outPoint\n  const { tx_hash: txHash, ...rest } = outPoint\n  return {\n    txHash,\n    ...rest,\n  }\n}\nconst toDepType = (type: RPC.DepType) => {\n  if (type === 'dep_group') {\n    return 'depGroup'\n  }\n  return type\n}\n\nconst toCellDep = (cellDep: RPC.CellDep): CKBComponents.CellDep => {\n  if (!cellDep) return cellDep\n  const { out_point: outPoint = null, dep_type = 'code', ...rest } = cellDep\n  return {\n    outPoint: toOutPoint(outPoint),\n    depType: toDepType(dep_type),\n    ...rest,\n  }\n}\nfunction toTransaction(tx: RPC.RawTransaction): CKBComponents.RawTransaction\nfunction toTransaction(tx: RPC.Transaction): CKBComponents.Transaction\nfunction toTransaction(tx: RPC.RawTransaction | RPC.Transaction): any {\n  if (!tx) return tx\n  const {\n    cell_deps: cellDeps = [],\n    inputs = [],\n    outputs = [],\n    outputs_data: outputsData = [],\n    header_deps: headerDeps = [],\n    ...rest\n  } = tx\n  return {\n    cellDeps: cellDeps.map(toCellDep),\n    inputs: inputs.map(toInput),\n    outputs: outputs.map(toOutput),\n    outputsData,\n    headerDeps,\n    ...rest,\n  }\n}\nconst toUncleBlock = (uncleBlock: RPC.UncleBlock): CKBComponents.UncleBlock => {\n  if (!uncleBlock) return uncleBlock\n  const { header, ...rest } = uncleBlock\n  return {\n    header: toHeader(header),\n    ...rest,\n  }\n}\n\nconst toBlock = (block: RPC.Block): CKBComponents.Block => {\n  if (!block) return block\n  const { header, uncles = [], transactions = [], ...rest } = block\n  return {\n    header: toHeader(header),\n    uncles: uncles.map(toUncleBlock),\n    transactions: transactions.map(toTransaction),\n    ...rest,\n  }\n}\nconst toAlertMessage = (alertMessage: RPC.AlertMessage): CKBComponents.AlertMessage => {\n  if (!alertMessage) return alertMessage\n  const { notice_until: noticeUntil, ...rest } = alertMessage\n  return {\n    noticeUntil,\n    ...rest,\n  }\n}\nconst toBlockchainInfo = (info: RPC.BlockchainInfo): CKBComponents.BlockchainInfo => {\n  if (!info) return info\n  const { is_initial_block_download: isInitialBlockDownload, median_time: medianTime, alerts, ...rest } = info\n  return {\n    isInitialBlockDownload,\n    medianTime,\n    alerts: alerts.map(toAlertMessage),\n    ...rest,\n  }\n}\nconst toLocalNodeInfo = (info: RPC.LocalNodeInfo): CKBComponents.LocalNodeInfo => {\n  if (!info) return info\n  const { node_id: nodeId, protocols, ...rest } = info\n  return {\n    nodeId,\n    protocols: protocols.map(({ id, name, support_versions: supportVersions }) => ({ id, name, supportVersions })),\n    ...rest,\n  }\n}\nconst toRemoteNodeInfo = (info: RPC.RemoteNodeInfo): CKBComponents.RemoteNodeInfo => {\n  if (!info) return info\n  const {\n    node_id: nodeId,\n    connected_duration: connectedDuration,\n    is_outbound: isOutbound,\n    last_ping_duration: lastPingDuration,\n    sync_state,\n    ...rest\n  } = info\n  return {\n    nodeId,\n    connectedDuration,\n    isOutbound,\n    lastPingDuration,\n    syncState: {\n      bestKnownHeaderHash: sync_state.best_known_header_hash,\n      bestKnownHeaderNumber: sync_state.best_known_header_number,\n      canFetchCount: sync_state.can_fetch_count,\n      inflightCount: sync_state.inflight_count,\n      lastCommonHeaderHash: sync_state.last_common_header_hash,\n      lastCommonHeaderNumber: sync_state.last_common_header_number,\n      unknownHeaderListSize: sync_state.unknown_header_list_size,\n    },\n    ...rest,\n  }\n}\nconst toTxPoolInfo = (info: RPC.TxPoolInfo): CKBComponents.TxPoolInfo => {\n  if (!info) return info\n  const {\n    last_txs_updated_at: lastTxsUpdatedAt,\n    tip_hash: tipHash,\n    tip_number: tipNumber,\n    total_tx_cycles: totalTxCycles,\n    total_tx_size: totalTxSize,\n    min_fee_rate: minFeeRate,\n    ...rest\n  } = info\n  return {\n    lastTxsUpdatedAt,\n    tipHash,\n    tipNumber,\n    totalTxCycles,\n    totalTxSize,\n    minFeeRate,\n    ...rest,\n  }\n}\nconst toPeers = (nodes: RPC.RemoteNodeInfo[]): CKBComponents.RemoteNodeInfo[] => {\n  if (!Array.isArray(nodes)) return []\n  return nodes.map(toRemoteNodeInfo)\n}\nconst toCell = (cell: RPC.Cell): CKBComponents.Cell => {\n  if (!cell) return cell\n  const { lock, type, ...rest } = cell\n  return {\n    lock: toScript(lock),\n    type: type ? toScript(type) : null,\n    ...rest,\n  }\n}\nconst toLiveCell = (liveCell: RPC.LiveCell): CKBComponents.LiveCell => {\n  if (!liveCell) return liveCell\n  const { data, output, ...rest } = liveCell\n  return {\n    data,\n    output: toOutput(output),\n    ...rest,\n  }\n}\nconst toLiveCellWithStatus = (cellWithStatus: {\n  cell: RPC.LiveCell\n  status: string\n}): { cell: CKBComponents.LiveCell; status: string } => {\n  if (!cellWithStatus) return cellWithStatus\n  const { cell, ...rest } = cellWithStatus\n  return {\n    cell: toLiveCell(cell),\n    ...rest,\n  }\n}\nconst toCells = (cells: RPC.Cell[]): CKBComponents.Cell[] => {\n  if (!Array.isArray(cells)) return []\n  return cells.map(toCell)\n}\nconst toCellIncludingOutPoint = (cell: RPC.CellIncludingOutPoint) => {\n  if (!cell) return cell\n  const { lock, block_hash: blockHash, out_point, output_data_len: outputDataLen, ...rest } = cell\n  return {\n    blockHash,\n    lock: toScript(lock),\n    outPoint: toOutPoint(out_point),\n    outputDataLen,\n    ...rest,\n  }\n}\nconst toCellsIncludingOutPoint = (cells: RPC.CellIncludingOutPoint[]): CKBComponents.CellIncludingOutPoint[] => {\n  if (!Array.isArray(cells)) return []\n  return cells.map(toCellIncludingOutPoint)\n}\nconst toTransactionWithStatus = (txWithStatus: RPC.TransactionWithStatus) => {\n  if (!txWithStatus) return txWithStatus\n  const {\n    transaction,\n    tx_status: { block_hash: blockHash, status },\n    ...rest\n  } = txWithStatus\n  return {\n    transaction: toTransaction(transaction),\n    txStatus: {\n      blockHash,\n      status,\n    },\n    ...rest,\n  }\n}\nconst toEpoch = (epoch: RPC.Epoch): CKBComponents.Epoch => {\n  if (!epoch) return epoch\n  const { start_number: startNumber, compact_target: compactTarget, ...rest } = epoch\n  return {\n    compactTarget,\n    startNumber,\n    ...rest,\n  }\n}\nconst toTransactionPoint = (transactionPoint: RPC.TransactionPoint): CKBComponents.TransactionPoint => {\n  if (!transactionPoint) return transactionPoint\n  const { block_number: blockNumber, tx_hash: txHash, ...rest } = transactionPoint\n  return {\n    blockNumber,\n    txHash,\n    ...rest,\n  }\n}\nconst toTransactionsByLockHash = (transactions: RPC.TransactionsByLockHash): CKBComponents.TransactionsByLockHash => {\n  if (!transactions) return transactions\n  return transactions.map(tx => ({\n    consumedBy: tx.consumed_by ? toTransactionPoint(tx.consumed_by) : tx.consumed_by,\n    createdBy: toTransactionPoint(tx.created_by),\n  }))\n}\nconst toLiveCellsByLockHash = (cells: RPC.LiveCellsByLockHash): CKBComponents.LiveCellsByLockHash => {\n  if (!cells) return cells\n  return cells.map(cell => ({\n    cellOutput: toCell(cell.cell_output),\n    createdBy: toTransactionPoint(cell.created_by),\n    cellbase: cell.cellbase,\n    outputDataLen: cell.output_data_len,\n  }))\n}\nconst toLockHashIndexState = (index: RPC.LockHashIndexState): CKBComponents.LockHashIndexState => {\n  if (!index) return index\n  const { block_hash: blockHash, block_number: blockNumber, lock_hash: lockHash, ...rest } = index\n  return {\n    blockHash,\n    blockNumber,\n    lockHash,\n    ...rest,\n  }\n}\nconst toLockHashIndexStates = (states: RPC.LockHashIndexStates): CKBComponents.LockHashIndexStates => {\n  if (!states) return states\n  return states.map(toLockHashIndexState)\n}\nconst toBannedAddress = (bannedAddress: RPC.BannedAddress): CKBComponents.BannedAddress => {\n  if (!bannedAddress) return bannedAddress\n  const { ban_reason: banReason, ban_until: banUntil, created_at: createdAt, ...rest } = bannedAddress\n  return {\n    banReason,\n    banUntil,\n    createdAt,\n    ...rest,\n  }\n}\nconst toBannedAddresses = (bannedAddresses: RPC.BannedAddresses): CKBComponents.BannedAddresses => {\n  if (!bannedAddresses) return bannedAddresses\n  return bannedAddresses.map(banAddr => toBannedAddress(banAddr))\n}\nconst toCellbaseOutputCapacityDetails = (\n  details: RPC.CellbaseOutputCapacityDetails,\n): CKBComponents.CellbaseOutputCapacityDetails => {\n  if (!details) return details\n  const { proposal_reward: proposalReward, tx_fee: txFee, ...rest } = details\n  return {\n    proposalReward,\n    txFee,\n    ...rest,\n  }\n}\n\nconst toFeeRate = (feeRateObj: RPC.FeeRate): CKBComponents.FeeRate => {\n  if (!feeRateObj) {\n    return feeRateObj\n  }\n  const { fee_rate: feeRate, ...rest } = feeRateObj\n  return {\n    feeRate,\n    ...rest,\n  }\n}\nconst toCapacityByLockHash = (capacityByLockHash: RPC.CapacityByLockHash): CKBComponents.CapacityByLockHash => {\n  if (!capacityByLockHash) {\n    return capacityByLockHash\n  }\n  const { cells_count: cellsCount, block_number: blockNumber, capacity, ...rest } = capacityByLockHash\n  return {\n    blockNumber,\n    capacity,\n    cellsCount,\n    ...rest,\n  }\n}\nconst toBlockEconomicState = (blockEconomicState: RPC.BlockEconomicState): CKBComponents.BlockEconomicState => {\n  if (!blockEconomicState) {\n    return blockEconomicState\n  }\n  const { finalized_at: finalizedAt, miner_reward: minerReward, txs_fee: txsFee, ...rest } = blockEconomicState\n  return {\n    finalizedAt,\n    minerReward,\n    txsFee,\n    ...rest,\n  }\n}\nconst toSyncState = (state: RPC.SyncState): CKBComponents.SyncState => {\n  if (!state) {\n    return state\n  }\n  return {\n    bestKnownBlockNumber: state.best_known_block_number,\n    bestKnownBlockTimestamp: state.best_known_block_timestamp,\n    fastTime: state.fast_time,\n    ibd: state.ibd,\n    inflightBlocksCount: state.inflight_blocks_count,\n    lowTime: state.low_time,\n    normalTime: state.normal_time,\n    orphanBlocksCount: state.orphan_blocks_count,\n  }\n}\nconst toTransactionProof = (proof: RPC.TransactionProof): CKBComponents.TransactionProof => {\n  if (!proof) {\n    return proof\n  }\n  const { block_hash: blockHash, witnesses_root: witnessesRoot, ...rest } = proof\n  return {\n    blockHash,\n    witnessesRoot,\n    ...rest,\n  }\n}\nconst toConsensus = (consensus: RPC.Consensus): CKBComponents.Consensus => {\n  if (!consensus) return consensus\n  return {\n    blockVersion: consensus.block_version,\n    cellbaseMaturity: consensus.cellbase_maturity,\n    daoTypeHash: consensus.dao_type_hash,\n    epochDurationTarget: consensus.epoch_duration_target,\n    genesisHash: consensus.genesis_hash,\n    id: consensus.id,\n    initialPrimaryEpochReward: consensus.initial_primary_epoch_reward,\n    maxBlockBytes: consensus.max_block_bytes,\n    maxBlockCycles: consensus.max_block_cycles,\n    maxBlockProposalsLimit: consensus.max_block_proposals_limit,\n    maxUnclesNum: consensus.max_uncles_num,\n    medianTimeBlockCount: consensus.median_time_block_count,\n    orphanRateTarget: consensus.orphan_rate_target,\n    permanentDifficultyInDummy: consensus.permanent_difficulty_in_dummy,\n    primaryEpochRewardHalvingInterval: consensus.primary_epoch_reward_halving_interval,\n    proposerRewardRatio: consensus.proposer_reward_ratio,\n    secondaryEpochReward: consensus.secondary_epoch_reward,\n    secp256k1Blake160MultisigAllTypeHash: consensus.secp256k1_blake160_multisig_all_type_hash,\n    secp256k1Blake160SighashAllTypeHash: consensus.secp256k1_blake160_sighash_all_type_hash,\n    txProposalWindow: consensus.tx_proposal_window,\n    txVersion: consensus.tx_version,\n    typeIdCodeHash: consensus.type_id_code_hash,\n    hardforkFeatures:\n      consensus.hardfork_features?.map(({ epoch_number: epochNumber, ...rest }) => ({ epochNumber, ...rest })) ??\n      consensus.hardfork_features,\n  }\n}\n\nconst toRawTxPool = (rawTxPool: RPC.RawTxPool): CKBComponents.RawTxPool => {\n  if (!rawTxPool) return rawTxPool\n\n  if (isTxPoolIds(rawTxPool)) {\n    return rawTxPool\n  }\n\n  const toTxVerbosity = ({\n    ancestors_count: ancestorsCount,\n    ancestors_cycles: ancestorsCycles,\n    ancestors_size: ancestorsSize,\n    ...rest\n  }: RPC.TxVerbosity): CKBComponents.TxVerbosity => ({\n    ancestorsCount,\n    ancestorsCycles,\n    ancestorsSize,\n    ...rest,\n  })\n  const proposed: Record<CKBComponents.Hash256, CKBComponents.TxVerbosity> = {}\n  const pending: Record<CKBComponents.Hash256, CKBComponents.TxVerbosity> = {}\n\n  Object.keys(rawTxPool.proposed).forEach(hash => {\n    proposed[hash] = toTxVerbosity(rawTxPool.proposed[hash])\n  })\n\n  Object.keys(rawTxPool.pending).forEach(hash => {\n    pending[hash] = toTxVerbosity(rawTxPool.pending[hash])\n  })\n\n  return { proposed, pending }\n}\n\n\n\nexport {\n  toNumber,\n  toHash,\n  toHeader,\n  toScript,\n  toInput,\n  toOutput,\n  toOutPoint,\n  toDepType,\n  toCellDep,\n  toTransaction,\n  toUncleBlock,\n  toBlock,\n  toAlertMessage,\n  toBlockchainInfo,\n  toLocalNodeInfo,\n  toRemoteNodeInfo,\n  toTxPoolInfo,\n  toPeers,\n  toLiveCell,\n  toLiveCellWithStatus,\n  toCell,\n  toCells,\n  toCellIncludingOutPoint,\n  toCellsIncludingOutPoint,\n  toTransactionWithStatus,\n  toEpoch,\n  toTransactionPoint,\n  toTransactionsByLockHash,\n  toLiveCellsByLockHash,\n  toLockHashIndexState,\n  toLockHashIndexStates,\n  toBannedAddress,\n  toBannedAddresses,\n  toCellbaseOutputCapacityDetails,\n  toFeeRate,\n  toCapacityByLockHash,\n  toBlockEconomicState,\n  toSyncState,\n  toTransactionProof,\n  toConsensus,\n  toRawTxPool,\n}\n/* eslint-enable camelcase */\n","import paramsFmts from '../paramsFormatter'\nimport * as resultFmts from '../resultFormatter'\n\nexport default {\n  getTipBlockNumber: {\n    method: 'get_tip_block_number',\n    paramsFormatters: [],\n    resultFormatters: resultFmts.toNumber,\n  },\n\n  getTipHeader: {\n    method: 'get_tip_header',\n    paramsFormatters: [],\n    resultFormatters: resultFmts.toHeader,\n  },\n\n  getCurrentEpoch: {\n    method: 'get_current_epoch',\n    paramsFormatters: [],\n    resultFormatters: resultFmts.toEpoch,\n  },\n\n  getEpochByNumber: {\n    method: 'get_epoch_by_number',\n    paramsFormatters: [paramsFmts.toNumber],\n    resultFormatters: resultFmts.toEpoch,\n  },\n\n  getBlockHash: {\n    method: 'get_block_hash',\n    paramsFormatters: [paramsFmts.toNumber],\n  },\n\n  getBlock: {\n    method: 'get_block',\n    paramsFormatters: [paramsFmts.toHash],\n    resultFormatters: resultFmts.toBlock,\n  },\n\n  getBlockByNumber: {\n    method: 'get_block_by_number',\n    paramsFormatters: [paramsFmts.toNumber],\n    resultFormatters: resultFmts.toBlock,\n  },\n\n  getHeader: {\n    method: 'get_header',\n    paramsFormatters: [paramsFmts.toHash],\n    resultFormatters: resultFmts.toHeader,\n  },\n\n  getHeaderByNumber: {\n    method: 'get_header_by_number',\n    paramsFormatters: [paramsFmts.toNumber],\n    resultFormatters: resultFmts.toHeader,\n  },\n\n  getLiveCell: {\n    method: 'get_live_cell',\n    paramsFormatters: [paramsFmts.toOutPoint],\n    resultFormatters: resultFmts.toLiveCellWithStatus,\n  },\n\n  getTransaction: {\n    method: 'get_transaction',\n    paramsFormatters: [paramsFmts.toHash],\n    resultFormatters: resultFmts.toTransactionWithStatus,\n  },\n\n  getCellbaseOutputCapacityDetails: {\n    method: 'get_cellbase_output_capacity_details',\n    paramsFormatters: [paramsFmts.toHash],\n    resultFormatters: resultFmts.toCellbaseOutputCapacityDetails,\n  },\n\n  getBlockEconomicState: {\n    method: 'get_block_economic_state',\n    paramsFormatters: [paramsFmts.toHash],\n    resultFormatters: resultFmts.toBlockEconomicState,\n  },\n\n  getTransactionProof: {\n    method: 'get_transaction_proof',\n    paramsFormatters: [paramsFmts.toArray(paramsFmts.toHash), paramsFmts.toOptional(paramsFmts.toHash)],\n    resultFormatters: resultFmts.toTransactionProof,\n  },\n\n  verifyTransactionProof: {\n    method: 'verify_transaction_proof',\n    paramsFormatters: [paramsFmts.toTransactionProof],\n  },\n\n  getConsensus: {\n    method: 'get_consensus',\n    paramsFormatters: [],\n    resultFormatters: resultFmts.toConsensus,\n  },\n}\n","import paramsFmts from '../paramsFormatter'\n\nexport default {\n  dryRunTransaction: {\n    method: 'dry_run_transaction',\n    paramsFormatters: [paramsFmts.toRawTransaction],\n  },\n\n  // skip _compute_transaction_hash\n\n  calculateDaoMaximumWithdraw: {\n    method: 'calculate_dao_maximum_withdraw',\n    paramsFormatters: [paramsFmts.toOutPoint, paramsFmts.toHash],\n  },\n\n  // skip estimate_fee_rate\n\n  // skip _compute_script_hash\n}\n","import paramsFmts from '../paramsFormatter'\nimport * as resultFmts from '../resultFormatter'\n\nexport default {\n  localNodeInfo: {\n    method: 'local_node_info',\n    paramsFormatters: [],\n    resultFormatters: resultFmts.toLocalNodeInfo,\n  },\n\n  getPeers: {\n    method: 'get_peers',\n    paramsFormatters: [],\n    resultFormatters: resultFmts.toPeers,\n  },\n\n  getBannedAddresses: {\n    method: 'get_banned_addresses',\n    paramsFormatters: [],\n    resultFormatters: resultFmts.toBannedAddresses,\n  },\n\n  clearBannedAddresses: {\n    method: 'clear_banned_addresses',\n    paramsFormatters: [],\n  },\n\n  setBan: {\n    method: 'set_ban',\n    paramsFormatters: [],\n  },\n\n  syncState: {\n    method: 'sync_state',\n    paramsFormatters: [],\n    resultFormatters: resultFmts.toSyncState,\n  },\n\n  setNetworkActive: {\n    method: 'set_network_active',\n    paramsFormatters: [paramsFmts.toBoolean],\n  },\n\n  addNode: {\n    method: 'add_node',\n    paramsFormatters: [],\n  },\n\n  removeNode: {\n    method: 'remove_node',\n    paramsFormatters: [],\n  },\n\n  pingPeers: {\n    method: 'ping_peers',\n    paramsFormatters: [],\n  },\n}\n","import paramsFmts from '../paramsFormatter'\nimport * as resultFmts from '../resultFormatter'\n\nexport default {\n  sendTransaction: {\n    method: 'send_transaction',\n    paramsFormatters: [paramsFmts.toRawTransaction, paramsFmts.toOutputsValidator],\n    resultFormatters: resultFmts.toHash,\n  },\n\n  txPoolInfo: {\n    method: 'tx_pool_info',\n    paramsFormatters: [],\n    resultFormatters: resultFmts.toTxPoolInfo,\n  },\n\n  clearTxPool: {\n    method: 'clear_tx_pool',\n    paramsFormatters: [],\n  },\n\n  getRawTxPool: {\n    method: 'get_raw_tx_pool',\n    paramsFormatters: [],\n    resultFormatters: resultFmts.toRawTxPool,\n  },\n}\n","import * as resultFmts from '../resultFormatter'\n\nexport default {\n  getBlockchainInfo: {\n    method: 'get_blockchain_info',\n    paramsFormatters: [],\n    resultFormatters: resultFmts.toBlockchainInfo,\n  },\n  getFeeRateStats: {\n    method: 'get_fee_rate_statistics',\n    paramsFormatters: [],\n  },\n}\n","import { CKBComponents } from '../../types'\nimport chainRpc from './chain'\nimport experimentalRpc from './experimental'\nimport netRpc from './net'\nimport poolRpc from './pool'\nimport statsRpc from './stats'\n\nexport interface RpcProperties {\n  [name: string]: Omit<CKBComponents.Method, 'name'>\n}\n\nexport const rpcProperties: RpcProperties = {\n  ...chainRpc,\n  ...experimentalRpc,\n  // skip minerRpc\n  ...netRpc,\n  ...poolRpc,\n  ...statsRpc,\n  // skip subscription\n}\n\nexport interface Base {\n  /* Chain */\n\n  /**\n   * @method getTipBlockNumber\n   * @memberof DefaultRPC\n   * @description rpc to get the number of blocks in the longest blockchain\n   * @return {Promise<string>} block number\n   */\n  getTipBlockNumber: () => Promise<CKBComponents.BlockNumber>\n\n  /**\n   * @method getTipHeader\n   * @memberof DefaultRPC\n   * @description rpc to get the tip header of the longeest blockchain\n   * @return {Promise<object>} block header\n   */\n  getTipHeader: () => Promise<CKBComponents.BlockHeader>\n\n  /**\n   * @method getCurrentEpoch\n   * @memberof DefaultRPC\n   * @description rpc to get the epoch info about the current epoch\n   * @return {Promise<object>} epoch info, including block reward, difficulty, last_block_hash_in_previous_epoch,\n   *                           length, number, remainder reward, start number\n   */\n  getCurrentEpoch: () => Promise<CKBComponents.Epoch>\n\n  /**\n   * @method getEpochByNumber\n   * @memberof DefaultRPC\n   * @description rpc to get the epoch info by its number\n   * @return {Promise<object>} epoch info\n   */\n  getEpochByNumber: (epoch: string | bigint) => Promise<CKBComponents.Epoch>\n\n  /**\n   * @method getBlockHash\n   * @memberof DefaultRPC\n   * @description rpc to get the block hash by block number\n   * @param {string} hash - block hash\n   * @return {Promise<string>} block hash\n   */\n  getBlockHash: (number: CKBComponents.BlockNumber | bigint) => Promise<CKBComponents.Hash>\n\n  /**\n   * @method getBlock\n   * @memberof DefaultRPC\n   * @description rpc to get block by its hash\n   * @param {string} hash - the block hash of the target block\n   * @returns {Promise<object>} block object\n   */\n  getBlock: (hash: CKBComponents.Hash) => Promise<CKBComponents.Block>\n\n  /**\n   * @method getHeader\n   * @memberof DefaultRPC\n   * @description Returns the information about a block header by hash.\n   * @params {Promise<string>} block hash\n   */\n  getHeader: (blockHash: CKBComponents.Hash) => Promise<CKBComponents.BlockHeader>\n\n  /**\n   * @method getHeaderByNumber\n   * @memberof DefaultRPC\n   * @description Returns the information about a block header by block number\n   * @params {Promise<string>} block number\n   */\n  getHeaderByNumber: (blockNumber: CKBComponents.BlockNumber | bigint) => Promise<CKBComponents.BlockHeader>\n\n  /**\n   * @method getLiveCell\n   * @memberof DefaultRPC\n   * @description rpc to get a cell by outPoint, the meaning of outPoint could be found in ckb-types,\n   *              please distinguish outPoint and cellOutPoint\n   * @param {object} outPoint - cell's outPoint\n   * @param {boolean} withData - set withData to true to return cell data and data hash if the cell is live\n   * @return {Promise<object>} liveCellWithStatus\n   */\n  getLiveCell: (\n    outPoint: CKBComponents.OutPoint,\n    withData: boolean,\n  ) => Promise<{\n    cell: CKBComponents.LiveCell\n    status: CKBComponents.CellStatus\n  }>\n\n  /**\n   * @method getTransaction\n   * @memberof DefaultRPC\n   * @description rpc to get trasnaction wtih its status by its hash\n   * @param {string} hash - the transaction hash of the target transaction\n   * @return {Promise<object>} transaction object with transaction status\n   */\n  getTransaction: (hash: CKBComponents.Hash) => Promise<CKBComponents.TransactionWithStatus>\n\n  /**\n   * @method getCellbaseOutputCapacityDetails\n   * @memberof DefaultRPC\n   * @description Returns each component of the created CKB in this block's cellbase, which is issued to\n   *              a block N - 1 - ProposalWindow.farthest, where this block's height is N.\n   * @param {string} blockHash\n   *\n   * @deprecated will be removed from v0.41.0\n   */\n  getCellbaseOutputCapacityDetails: (\n    blockHash: CKBComponents.Hash,\n  ) => Promise<CKBComponents.CellbaseOutputCapacityDetails>\n\n  /**\n   * @method getBlockEconomicState\n   * @memberof DefaultRPC\n   * @description\n   * @param {string} blockHash\n   * @returns {Promise<BlockEconomicState>}\n   */\n  getBlockEconomicState: (blockHash: CKBComponents.Hash) => Promise<CKBComponents.BlockEconomicState>\n\n  /**\n   * @method getTransactionProof\n   * @memberof DefaultRPC\n   * @description request merkle proof that transactions are included in a block\n   * @param {Array<string>} transactionHashes - transaction hashes, all transactions must be in the same block\n   * @param {Promise<[string]>} blockHash - if specified, looks for transactions in the block with this hash\n   */\n  getTransactionProof: (\n    transactionHashes: CKBComponents.Hash[],\n    blockHash?: CKBComponents.Hash,\n  ) => Promise<CKBComponents.TransactionProof>\n\n  /**\n   * @method verifyTransactionProof\n   * @memberof DefaultRPC\n   * @description verifies that a proof points to transactions in a block, returns transactions it commits to.\n   * @param {object} transactionProof\n   * @returns {Promise<Array<string>>} hash list of transactions committed in the block\n   */\n  verifyTransactionProof: (transactionProof: CKBComponents.TransactionProof) => Promise<CKBComponents.Hash[]>\n\n  /**\n   * @method getConsensus\n   * @memberof DefaultRPC\n   * @description return various consensus parameters.\n   * @returns {Promise<object>} consensus parameters\n   */\n  getConsensus: () => Promise<CKBComponents.Consensus>\n\n  /**\n   * @method getBlockByNumber\n   * @memberof DefaultRPC\n   * @description rpc to get block by its number\n   * @param {string} number - the block number of the target block\n   * @returns {Promise<object>} block object\n   */\n  getBlockByNumber: (number: CKBComponents.BlockNumber | bigint) => Promise<CKBComponents.Block>\n\n  /* Experimental */\n\n  /**\n   * @method dryRunTransaction\n   * @memberof DefaultRPC\n   * @description dry run the transaction and return the execution cycles, this method will not check the transaction\n   *              validaty, but only run the lock script and type script and then return the execution cycles.\n   * @param {object} rawTrasnaction - the raw transaction whose cycles is going to be calculated\n   * @return {Promise<object>} dry run result, including cycles the transaction used.\n   */\n  dryRunTransaction: (tx: CKBComponents.RawTransaction) => Promise<CKBComponents.RunDryResult>\n\n  calculateDaoMaximumWithdraw: (\n    outPoint: CKBComponents.OutPoint,\n    withdrawBlockHash: CKBComponents.Hash256,\n  ) => Promise<string>\n\n  /* skip Miner */\n\n  /* Net */\n\n  /**\n   * @method localNodeInfo\n   * @memberof DefaultRPC\n   * @description rpc to get the local node information\n   * @return {Promise<object>} node info, including addresses, is_outbound, node id, and version\n   */\n  localNodeInfo: () => Promise<CKBComponents.LocalNodeInfo>\n\n  /**\n   * @method getPeers\n   * @memberof DefaultRPC\n   * @description rpc to get connected peers info\n   * @return {Promise<object[]>} peers' node info\n   *\n   * @deprecated will be removed from v0.41.0\n   */\n  getPeers: () => Promise<CKBComponents.RemoteNodeInfo[]>\n\n  /**\n   * @method getBannedAddresses\n   * @memberof DefaultRPC\n   * @description Returns all banned IPs/Subnets\n   */\n  getBannedAddresses: () => Promise<CKBComponents.BannedAddresses>\n\n  /**\n   * @method clearBannedAddresses\n   * @memberof DefaultRPC\n   * @description clear all banned IPs/Subnets\n   * @returns <null>\n   */\n  clearBannedAddresses: () => Promise<null>\n\n  /**\n   * @method setBan\n   * @memberof DefaultRPC\n   * @description insert or delete an IP/Subnet from the banned list\n   * @param {string} address, The IP/Subnet with an optional netmask (default is /32 = single IP)\n   * @param {insert|delete} command, `insert` to insert an IP/Subnet to the list, `delete` to delete an IP/Subnet\n   *                                 from the list\n   * @param {string|null} ban_time, Time in milliseconds how long (or until when if [absolute] is set) the IP is banned,\n   *                                optional parameter, null means using the default time of 24h\n   * @param {[boolean]} absolute, If set, the `ban_time` must be an absolute timestamp in milliseconds since epoch,\n   *                              optional parameter\n   * @param {[string]} reason, Ban reason, optional parameter\n   */\n\n  setBan: (\n    address: string,\n    command: 'insert' | 'delete',\n    banTime: string | null,\n    absolute?: boolean,\n    reason?: string,\n  ) => Promise<null>\n\n  /**\n   * @method syncState\n   * @memberof DefaultRPC\n   * @description return sync state of this node\n   */\n  syncState: () => Promise<CKBComponents.SyncState>\n\n  /**\n   * @method setNetworkActive\n   * @memberof DefaultRPC\n   * @description disable/enable all p2p network activity\n   * @param {boolean} state - true to enable networking, false to disable\n   */\n  setNetworkActive: (state: boolean) => Promise<null>\n\n  /**\n   * @method addNode\n   * @memberof DefaultRPC\n   * @description attempt to add a node to the peer list and try to connect\n   * @param {string} peerId - the peer id of target node\n   * @param {string} address - the address of target node\n   * @returns {Promise<null>}\n   */\n  addNode: (peerId: string, address: string) => Promise<null>\n\n  /**\n   * @method removeNode\n   * @memberof DefaultRPC\n   * @description attempt to remove a node from the peer list and try to disconnect\n   * @param {string} peerId - the peer id of the target node\n   * @returns {Promise<null>}\n   */\n  removeNode: (peerId: string) => Promise<null>\n\n  /**\n   * @method pingPeers\n   * @memberof DefaultRPC\n   * @description request a ping sent to all connected peers to measure ping time\n   * @returns {Promise<null>}\n   */\n  pingPeers: () => Promise<null>\n\n  /* Pool */\n\n  /**\n   * @method sendTransaction\n   * @memberof DefaultRPC\n   * @description rpc to send a new transaction into transaction pool\n   * @param {object} rawTransaction - a raw transaction includes cell deps, inputs, outputs, version, and witnesses,\n   *                                  detailed info could be found in ckb-types\n   * @param {string} [outputsValidator] - Validates the transaction outputs before entering the tx-pool,\n   *                                  an optional string parameter (enum: default | passthrough ),\n   *                                  null and passthrough mean skipping outputs validation\n   * @return {Promise<string>} transaction hash\n   */\n  sendTransaction: (\n    tx: CKBComponents.RawTransaction,\n    outputsValidator?: CKBComponents.OutputsValidator,\n  ) => Promise<CKBComponents.Hash>\n\n  /**\n   * @method txPoolInfo\n   * @memberof DefaultRPC\n   * @description rpc to get pool information\n   * @return {Promise<object>} info of transaction pool, including last_txs_updated_at, number of orphan,\n   *                           number of pending, number of proposed\n   */\n  txPoolInfo: () => Promise<CKBComponents.TxPoolInfo>\n\n  /**\n   * @method clearTxPool\n   * @memberof DefaultRPC\n   * @description remove all transactions from the tx pool\n   * @return {Promise<null>}\n   */\n  clearTxPool: () => Promise<null>\n\n  /**\n   * @method getRawTxPool\n   * @memberof DefaultRPC\n   * @param {boolean | null} verbose - true for a json object, false for array of transaction ids, default=false\n   * @description Returns all transaction ids in tx pool as a json array of string transaction ids.\n   * @return {Promise<object>} CKBComponents.RawTxPool\n   */\n  getRawTxPool(): Promise<CKBComponents.TxPoolIds>\n  getRawTxPool(verbose: true): Promise<CKBComponents.TxPoolVerbosity>\n  getRawTxPool(verbose: false | null): Promise<CKBComponents.TxPoolIds>\n\n  /* Stats */\n\n  /**\n   * @method getBlockchainInfo\n   * @memberof DefaultRPC\n   * @description rpc to get state info of the blockchain\n   * @return {Promise<object>} blockchain info, including chain name, difficulty, epoch number,\n   *                           is_initial_block_download, median time, warnings\n   */\n  getBlockchainInfo: () => Promise<CKBComponents.BlockchainInfo>\n\n  /* skip Subscription */\n\n  getFeeRateStats: () => Promise<CKBComponents.FeeRateStats | null>\n}\n\nexport class Base {\n  #rpcProperties = rpcProperties\n\n  get rpcProperties() {\n    return this.#rpcProperties\n  }\n}\n\nexport default Base\n","import axios from 'axios'\nimport { IdNotMatchException, ResponseException } from './exceptions'\nimport { CKBComponents } from '../types'\n\nexport class Method {\n  #name: string\n\n  get name() {\n    return this.#name\n  }\n\n  #options: CKBComponents.Method = {\n    name: '',\n    method: '',\n    paramsFormatters: [],\n    resultFormatters: undefined,\n  }\n\n  #node: CKBComponents.Node\n\n  constructor(node: CKBComponents.Node, options: CKBComponents.Method) {\n    this.#node = node\n    this.#options = options\n    this.#name = options.name\n    Object.defineProperty(this.call, 'name', { value: options.name, configurable: false, writable: false })\n  }\n\n  public call = (...params: (string | number | object)[]) => {\n    const payload = this.getPayload(...params)\n    return axios({\n      method: 'POST',\n      headers: {\n        'content-type': 'application/json',\n      },\n      data: payload,\n      url: this.#node.url,\n      httpAgent: this.#node.httpAgent,\n      httpsAgent: this.#node.httpsAgent,\n    }).then(res => {\n      if (res.data.id !== payload.id) {\n        throw new IdNotMatchException(payload.id, res.data.id)\n      }\n      if (res.data.error) {\n        throw new ResponseException(JSON.stringify(res.data.error))\n      }\n      return this.#options.resultFormatters?.(res.data.result) ?? res.data.result\n    })\n  }\n\n  public getPayload = (...params: (string | number | object)[]) => {\n    const data = params.map((p, i) => (this.#options.paramsFormatters[i] && this.#options.paramsFormatters[i](p)) || p)\n    const id = Math.round(Math.random() * 10000)\n    const payload = {\n      id,\n      method: this.#options.method,\n      params: data,\n      jsonrpc: '2.0',\n    }\n    return payload\n  }\n}\n","import { CKBComponents, RawTransactionParams } from '../types'\nimport { scriptToHash, JSBI } from '../utils'\nimport { EMPTY_WITNESS_ARGS } from '../utils/const'\nimport { assertToBeHexStringOrBigint } from '../utils/validators'\n\nconst EMPTY_DATA = '0x'\nconst MIN_CELL_CAPACITY = `0x${(61_00_000_000).toString(16)}`\n\nexport const getBigInts = ({ fee, capacityThreshold, changeThreshold }: { [key: string]: string | bigint }) => {\n  assertToBeHexStringOrBigint(fee!)\n  assertToBeHexStringOrBigint(capacityThreshold!)\n  assertToBeHexStringOrBigint(changeThreshold!)\n  return {\n    targetFee: JSBI.BigInt(`${fee}`),\n    minCapacity: JSBI.BigInt(`${capacityThreshold}`),\n    minChange: JSBI.BigInt(`${changeThreshold}`),\n    zeroBigInt: JSBI.BigInt(0),\n  }\n}\n\nexport const getKeyAndCellsPairs = (\n  params:\n    | Pick<RawTransactionParams.Simple, 'inputScript' | 'outputScript' | 'capacity' | 'cells'>\n    | Pick<RawTransactionParams.Complex, 'inputScripts' | 'outputs' | 'cells'>,\n) => {\n  const inputScripts = 'inputScript' in params ? [params.inputScript] : params.inputScripts\n  const outputs: RawTransactionParams.Output[] =\n    'outputScript' in params ? [{ lock: params.outputScript, capacity: params.capacity }] : params.outputs\n\n  let unspentCellsMap = new Map<RawTransactionParams.LockHash, RawTransactionParams.Cell[]>()\n\n  if ('inputScript' in params) {\n    const lockHash = scriptToHash(params.inputScript)\n    unspentCellsMap.set(lockHash, params.cells || [])\n  } else {\n    unspentCellsMap = params.cells || new Map()\n  }\n  return { inputScripts, outputs, unspentCellsMap }\n}\n\nexport const getTargetOutputs = ({\n  outputs,\n  minCapacity,\n}: {\n  outputs: ReturnType<typeof getKeyAndCellsPairs>['outputs']\n  minCapacity: JSBI\n}) => {\n  return outputs.map(output => {\n    const capacity = JSBI.BigInt(`${output.capacity}`)\n    if (JSBI.lessThan(capacity, minCapacity)) {\n      throw new Error(`Capacity should be at least ${minCapacity} shannon`)\n    }\n    return { ...output, capacity }\n  })\n}\n\nexport const getInputs = ({\n  inputScripts,\n  safeMode,\n  costCapacity,\n  unspentCellsMap,\n}: {\n  inputScripts: CKBComponents.Script[]\n  unspentCellsMap: ReturnType<typeof getKeyAndCellsPairs>['unspentCellsMap']\n  safeMode: boolean\n  costCapacity: JSBI\n}) => {\n  const inputs: Array<CKBComponents.CellInput & { lockHash: string }> = []\n\n  let sum = JSBI.BigInt(0)\n  for (let i = 0; i < inputScripts.length; i++) {\n    const lockHash = scriptToHash(inputScripts[i])\n    const unspentCells = unspentCellsMap.get(lockHash) || []\n\n    for (let j = 0; j < unspentCells.length; j++) {\n      const c = unspentCells[j]\n\n      if (!safeMode || (c.data === EMPTY_DATA && !c.type)) {\n        inputs.push({ previousOutput: c.outPoint, since: '0x0', lockHash })\n        sum = JSBI.add(sum, JSBI.BigInt(c.capacity))\n        if (JSBI.greaterThanOrEqual(sum, costCapacity)) {\n          break\n        }\n      }\n    }\n\n    if (JSBI.greaterThan(sum, costCapacity)) {\n      break\n    }\n  }\n\n  if (JSBI.lessThan(sum, costCapacity)) {\n    throw new Error('Input capacity is not enough')\n  }\n  return { inputs, sum }\n}\n\nexport const getLeftCells = ({\n  usedCells,\n  inputScripts,\n  unspentCellsMap,\n}: {\n  inputScripts: CKBComponents.Script[]\n  usedCells: CKBComponents.CellInput[]\n  unspentCellsMap: ReturnType<typeof getKeyAndCellsPairs>['unspentCellsMap']\n}): Array<{ capacity: string; outPoint: CKBComponents.OutPoint }> => {\n  const leftCells: Array<{ capacity: string; outPoint: CKBComponents.OutPoint }> = []\n\n  const isCellUsed = (cell: Pick<RawTransactionParams.Cell, 'outPoint'>) =>\n    usedCells.some(\n      used =>\n        used.previousOutput?.txHash === cell.outPoint?.txHash && used.previousOutput?.index === cell.outPoint?.index,\n    )\n\n  inputScripts.forEach(script => {\n    const lockhash = scriptToHash(script)\n    const cells = unspentCellsMap.get(lockhash)\n    if (cells?.length) {\n      cells.forEach(cell => {\n        if (cell.data === EMPTY_DATA && !cell.type && !isCellUsed(cell)) {\n          leftCells.push({\n            outPoint: cell.outPoint!,\n            capacity: cell.capacity,\n          })\n        }\n      })\n    }\n  })\n\n  return leftCells\n}\n\nconst isFee = (fee: RawTransactionParams.Fee): fee is RawTransactionParams.Capacity => typeof fee !== 'object'\n\nexport const generateRawTransaction = ({\n  fee = '0x0',\n  changeLockScript,\n  safeMode = true,\n  deps,\n  capacityThreshold = MIN_CELL_CAPACITY,\n  changeThreshold = MIN_CELL_CAPACITY,\n  ...params\n}: RawTransactionParams.Simple | RawTransactionParams.Complex): CKBComponents.RawTransactionToSign => {\n  if (!deps) {\n    throw new Error('The dep is not loaded')\n  }\n\n  const { targetFee, minCapacity, minChange, zeroBigInt } = getBigInts({\n    fee: isFee(fee) ? fee : '0x0',\n    capacityThreshold,\n    changeThreshold,\n  })\n  const { inputScripts, outputs: toOutputs, unspentCellsMap } = getKeyAndCellsPairs(params)\n  const targetOutputs = getTargetOutputs({ outputs: toOutputs, minCapacity })\n  const targetCapacity = targetOutputs.reduce((acc, o) => JSBI.add(acc, o.capacity), zeroBigInt)\n  const costCapacity = JSBI.add(JSBI.add(targetCapacity, targetFee), minChange)\n\n  const changeOutput = {\n    capacity: zeroBigInt,\n    lock: (changeLockScript || inputScripts[0])!,\n  }\n\n  const { inputs, sum: inputSum } = getInputs({ inputScripts, safeMode, costCapacity, unspentCellsMap })\n\n  if (JSBI.greaterThan(inputSum, JSBI.add(targetCapacity, targetFee))) {\n    changeOutput.capacity = JSBI.subtract(JSBI.subtract(inputSum, targetCapacity), targetFee)\n  }\n\n  const outputs = targetOutputs.map(o => ({ ...o, capacity: `0x${o.capacity.toString(16)}` }))\n\n  if (JSBI.greaterThan(changeOutput.capacity, zeroBigInt)) {\n    outputs.push({ ...changeOutput, capacity: `0x${changeOutput.capacity.toString(16)}` })\n  }\n\n  const cellDeps = Array.isArray(deps) ? deps : [deps]\n\n  const witnesses = params.witnesses ?? []\n  inputs.forEach((input, idx) => {\n    if (!witnesses[idx]) {\n      witnesses[idx] = input.lockHash !== inputs[idx - 1]?.lockHash ? EMPTY_WITNESS_ARGS : '0x'\n    }\n  })\n\n  const outputsData = params.outputsData ?? []\n  outputs.forEach((_, idx) => {\n    if (!outputsData[idx]) {\n      outputsData[idx] = '0x'\n    }\n  })\n\n  const tx = {\n    version: '0x0',\n    cellDeps: cellDeps.map(dep => ({ outPoint: dep.outPoint, depType: dep.depType })),\n    headerDeps: [],\n    inputs: inputs.map(({ previousOutput, since }) => ({ previousOutput, since })),\n    outputs,\n    witnesses,\n    outputsData,\n  }\n\n  if (!isFee(fee)) {\n    const leftCells = getLeftCells({ inputScripts, usedCells: tx.inputs, unspentCellsMap })\n    return fee.reconciler({ tx, feeRate: fee.feeRate, changeThreshold, cells: leftCells, extraCount: 10 })\n  }\n  return tx\n}\n","import { LoadCellsParams, RawTransactionParams } from \"../types\"\n\nexport const loadCellsFromIndexer = async ({\n  CellCollector,\n  indexer,\n  lock,\n  start,\n  end,\n}: LoadCellsParams.FromIndexer) => {\n  const collector = new CellCollector(indexer, {\n    lock: {\n      code_hash: lock.codeHash,\n      hash_type: lock.hashType,\n      args: lock.args,\n    },\n    fromBlock: start,\n    toBlock: end,\n  })\n\n  const cells: RawTransactionParams.Cell[] = []\n\n  /* eslint-disable no-restricted-syntax, camelcase */\n  for await (const {\n    data,\n    cell_output: { capacity, type },\n    out_point,\n  } of collector.collect()) {\n    cells.push({\n      data,\n      lock,\n      type: type && { codeHash: type.code_hash, hashType: type.hash_type, args: type.args },\n      capacity,\n      outPoint: { txHash: out_point.tx_hash, index: out_point.index },\n    })\n  }\n  /* eslint-enable no-restricted-syntax */\n\n  return cells\n}\n","import { CKBComponents } from '../types'\nimport { blake2b, PERSONAL, hexToBytes } from '../utils'\n\nexport type MultisigConfig = {\n  r: number\n  m: number\n  n: number\n  blake160s: string[]\n}\n\nexport function isMultisigConfig(config: any): config is MultisigConfig {\n  return config\n    && !Number.isNaN(+config.r)\n    && !Number.isNaN(+config.m)\n    && !Number.isNaN(+config.n)\n    && Array.isArray(config.blake160s)\n}\n\nexport type Signatures = Record<CKBComponents.Hash, CKBComponents.Bytes[]>\n\nexport enum SignStatus {\n  Signed = 'Signed',\n  Unsigned = 'Unsigned',\n  PartiallySigned = 'PartiallySigned'\n}\n\nconst validateMultisigCount = (v: number) => {\n  if (v < 0 || v > 255) {\n    throw new Error('For multisig sign, signer should between 0 and 255')\n  }\n}\n\nconst toHex = (v: number) => {\n  return v.toString(16).padStart(2, '0')\n}\n\nconst validateMultisigConfig = (config: MultisigConfig) => {\n  validateMultisigCount(config.r)\n  validateMultisigCount(config.m)\n  validateMultisigCount(config.n)\n  if (config.m > config.n) throw new Error(`For m of n multisig sign, m shouldn't be greater than n`)\n  if (config.r > config.m) throw new Error(`For m of n multisig sign, r shouldn't be greater than m`)\n  if (config.n !== config.blake160s.length) throw new Error(`For m of n multisig sign, signer's length should equal with n`)\n}\n\nexport const serializeMultisigConfig = (config: MultisigConfig) => {\n  validateMultisigConfig(config)\n  // default s is 00\n  return `0x00${toHex(config.r)}${toHex(config.m)}${toHex(config.n)}${config.blake160s.reduce((pre, cur) => pre + cur.slice(2), '')}`\n}\n\nexport const hashMultisig = (config: MultisigConfig) => {\n  const blake2bHash = blake2b(32, null, null, PERSONAL)\n  blake2bHash.update(hexToBytes(serializeMultisigConfig(config)))\n  return `0x${blake2bHash.digest('hex')}`.slice(0, 42)\n}\n\nexport const getMultisigStatus = (config: MultisigConfig, signatures: CKBComponents.Bytes[] = []) => {\n  let signedForM = 0\n  let signedForR = 0\n  for (let i = 0; i < config.n; i++) {\n    if (signatures.includes(config.blake160s[i])) {\n      if (i < config.r) {\n        signedForR += 1\n      } else {\n        signedForM += 1\n      }\n    }\n  }\n  if (signedForM + signedForR === 0) {\n    return SignStatus.Unsigned\n  }\n  if (signedForM > config.m - config.r) {\n    throw new Error('More signature for multisig')\n  }\n  if (signedForM + signedForR < config.m) {\n    return SignStatus.PartiallySigned\n  }\n  return SignStatus.Signed\n}\n","import { StructuredWitness } from '../types'\nimport { blake2b, hexToBytes, PERSONAL, toUint64Le, serializeWitnessArgs } from '../utils'\nimport { ECPair } from '../utils/ecpair'\nimport { serializeMultisigConfig, MultisigConfig } from './multisig'\n\nexport type SignatureProvider = string | ((message: string | Uint8Array) => string)\ntype TransactionHash = string\n\nexport function signWitnessGroup(\n  sk: SignatureProvider,\n  transactionHash: TransactionHash,\n  witnessGroup: StructuredWitness[],\n  multisigConfig?: MultisigConfig,\n): StructuredWitness[]\nexport function signWitnessGroup(\n  sk: (message: string | Uint8Array, witness: StructuredWitness[]) => Promise<string>,\n  transactionHash: TransactionHash,\n  witnessGroup: StructuredWitness[],\n  multisigConfig?: MultisigConfig,\n): Promise<StructuredWitness[]>\n\nexport function signWitnessGroup(\n  sk: SignatureProvider | ((message: string | Uint8Array, witness: StructuredWitness[]) => Promise<string>),\n  transactionHash: TransactionHash,\n  witnessGroup: StructuredWitness[],\n  multisigConfig?: MultisigConfig\n) {\n  if (!witnessGroup.length) {\n    throw new Error('WitnessGroup cannot be empty')\n  }\n  if (typeof witnessGroup[0] !== 'object') {\n    throw new Error('The first witness in the group should be type of WitnessArgs')\n  }\n\n  const emptyWitness = {\n    ...witnessGroup[0],\n    lock: `0x${'0'.repeat(130)}`,\n  }\n  if (multisigConfig) {\n    emptyWitness.lock = `${serializeMultisigConfig(multisigConfig)}${'0'.repeat(130 * multisigConfig.m)}`\n  }\n\n  const serializedEmptyWitnessBytes = hexToBytes(serializeWitnessArgs(emptyWitness))\n  const serializedEmptyWitnessSize = serializedEmptyWitnessBytes.length\n\n  const s = blake2b(32, null, null, PERSONAL)\n  s.update(hexToBytes(transactionHash))\n  s.update(hexToBytes(toUint64Le(`0x${serializedEmptyWitnessSize.toString(16)}`)))\n  s.update(serializedEmptyWitnessBytes)\n\n  witnessGroup.slice(1).forEach(w => {\n    const bytes = hexToBytes(typeof w === 'string' ? w : serializeWitnessArgs(w))\n    s.update(hexToBytes(toUint64Le(`0x${bytes.length.toString(16)}`)))\n    s.update(bytes)\n  })\n\n  const message = `0x${s.digest('hex')}`\n  if (typeof sk === 'string') {\n    const keyPair = new ECPair(sk)\n    emptyWitness.lock = keyPair.signRecoverable(message)\n    return [multisigConfig ? emptyWitness : serializeWitnessArgs(emptyWitness), ...witnessGroup.slice(1)]\n  } else {\n    const skResult = sk(message, [emptyWitness, ...witnessGroup.slice(1)])\n    if (typeof skResult === 'string') {\n      emptyWitness.lock = skResult\n      return [multisigConfig ? emptyWitness : serializeWitnessArgs(emptyWitness), ...witnessGroup.slice(1)]\n    }\n    return skResult.then(res => {\n      emptyWitness.lock = res\n      return [multisigConfig ? emptyWitness : serializeWitnessArgs(emptyWitness), ...witnessGroup.slice(1)]\n    })\n  }\n}\n","import { CKBComponents } from '../types'\nimport { scriptToHash } from '../utils'\n\ntype LockHash = string\ntype Index = number\ntype Cell = { lock: CKBComponents.Script }\n\nexport const groupScripts = (inputCells: Cell[]) => {\n  const groups = new Map<LockHash, Index[]>()\n  inputCells.forEach((cell, i) => {\n    const lockHash = scriptToHash(cell.lock)\n    const group = groups.get(lockHash) || []\n    groups.set(lockHash, [...group, i])\n  })\n  return groups\n}\n","import { serializeWitnessArgs } from '../utils'\nimport { ParameterRequiredException } from '../utils/exceptions'\nimport { SignatureProvider, signWitnessGroup } from './signWitnessGroup'\nimport { groupScripts } from './groupScripts'\nimport { getMultisigStatus, isMultisigConfig, MultisigConfig, serializeMultisigConfig, SignStatus } from './multisig'\nimport { CKBComponents, StructuredWitness } from '../types'\n\ntype LockHash = string\ntype TransactionHash = string\ntype CachedLock = { lock: CKBComponents.Script }\nexport type MultisigOption = {\n  sk: SignatureProvider\n  blake160: string\n  config: MultisigConfig\n  signatures: string[]\n}\n\ntype SignWitnessesKey = SignatureProvider | Map<LockHash, SignatureProvider | MultisigOption>\nexport interface SignWitnesses {\n  (key: SignatureProvider): (params: {\n    transactionHash: TransactionHash\n    witnesses: StructuredWitness[]\n  }) => StructuredWitness[]\n  (key: Map<LockHash, SignatureProvider | MultisigOption>): (params: {\n    transactionHash: TransactionHash\n    witnesses: StructuredWitness[]\n    inputCells: CachedLock[]\n    skipMissingKeys: boolean\n  }) => StructuredWitness[]\n  (key: SignWitnessesKey): (params: {\n    transactionHash: TransactionHash\n    witnesses: StructuredWitness[]\n    inputCells?: CachedLock[]\n    skipMissingKeys?: boolean\n  }) => StructuredWitness[]\n}\n\nexport const isMap = <K = any, V = any>(val: any): val is Map<K, V> => {\n  return val.size !== undefined\n}\n\nfunction isMultisigOption(params: any): params is MultisigOption {\n  if (params.sk && params.blake160 && params.config && params.signatures) {\n    if ((typeof params.sk === 'string' || typeof params.sk === 'function')\n      && typeof params.blake160 === 'string'\n      && Array.isArray(params.signatures)\n      && isMultisigConfig(params.config)\n    ) {\n        return true\n    }\n    throw new Error('Multisig options is incorrect')\n  }\n  throw new Error('Multisig options miss some property')\n}\n\nexport const signWitnesses: SignWitnesses = (key: SignWitnessesKey) =>\n  ({\n    transactionHash,\n    witnesses = [],\n    inputCells = [],\n    skipMissingKeys = false,\n  }: {\n    transactionHash: string\n    witnesses: StructuredWitness[]\n    inputCells?: CachedLock[]\n    skipMissingKeys?: boolean\n  }) => {\n    if (!key) throw new ParameterRequiredException('Signature provider')\n    if (!transactionHash) throw new ParameterRequiredException('Transaction hash')\n    if (!witnesses.length) throw new Error('Witnesses is empty')\n\n    if (isMap(key)) {\n      if (!inputCells.length) {\n        throw new Error(`Cell shouldn't be empty when key is Map`)\n      }\n      const rawWitnesses = witnesses\n      const restWitnesses = witnesses.slice(inputCells.length)\n      const groupedScripts = groupScripts(inputCells)\n      groupedScripts.forEach((indices, lockHash) => {\n        const sk = key.get(lockHash)\n        if (!sk) {\n          if (!skipMissingKeys) {\n            throw new Error(`The signature provider to sign lock hash ${lockHash} is not found`)\n          } else {\n            return\n          }\n        }\n\n        const ws = [...indices.map(idx => witnesses[idx]), ...restWitnesses] as StructuredWitness[]\n        if (typeof sk === 'object' && isMultisigOption(sk)) {\n          const witnessIncludeSignature = signWitnessGroup(sk.sk, transactionHash, ws, sk.config)[0]\n          // is multisig sign\n          const firstWitness = rawWitnesses[indices[0]]\n          if (typeof firstWitness !== 'object') {\n            throw new Error('The first witness in the group should be type of WitnessArgs')\n          }\n          let lockAfterSign = (witnessIncludeSignature as CKBComponents.WitnessArgs).lock\n          if (firstWitness.lock) {\n            lockAfterSign = firstWitness.lock + lockAfterSign?.slice(2)\n          } else {\n            lockAfterSign = serializeMultisigConfig(sk.config) + lockAfterSign?.slice(2)\n          }\n          const firstWitSigned = { ...firstWitness, lock: lockAfterSign }\n          rawWitnesses[indices[0]] = firstWitSigned\n          if (getMultisigStatus(sk.config, [...sk.signatures, sk.blake160]) === SignStatus.Signed) {\n            indices.forEach(idx => {\n              const wit = rawWitnesses[idx]\n              rawWitnesses[idx] = typeof wit === 'string' ? wit : serializeWitnessArgs(wit!)\n            })\n          }\n        } else {\n          const witnessIncludeSignature = signWitnessGroup(sk, transactionHash, ws)[0]\n          rawWitnesses[indices[0]] = witnessIncludeSignature!\n        }\n      })\n      return rawWitnesses\n    }\n\n    return signWitnessGroup(key, transactionHash, witnesses)\n  }\n\n","import { BranchRPC } from '../rpc'\nimport { ParameterRequiredException } from '../utils/exceptions'\nimport * as utils from '../utils'\n\nimport { generateRawTransaction } from './generateRawTransaction'\n\nimport {loadCellsFromIndexer} from './loadCellsFromIndexer'\nimport { isMap, signWitnesses } from './signWitnesses'\nimport { CKBComponents, DepCellInfo, LoadCellsParams, RawTransactionParams } from '../types'\n\nconst filterCellsByInputs = (\n  cells: Pick<RawTransactionParams.Cell, 'outPoint' | 'lock'>[],\n  inputs: Pick<CKBComponents.CellInput, 'previousOutput'>[],\n) => {\n  return inputs.map(input => {\n    const outPoint = input.previousOutput\n    const cell = cells.find(c => c.outPoint?.txHash === outPoint?.txHash && c.outPoint?.index === outPoint?.index)\n    if (!cell) {\n      throw new Error(`Cell of ${JSON.stringify(outPoint)} is not found`)\n    }\n    return cell\n  })\n}\n\ntype Key = string\ntype Address = string\ntype LockHash = string\ntype Capacity = bigint | string\ntype URL = string\n\ninterface SimpleRawTransactionParams extends RawTransactionParams.Base {\n  fromAddress: Address\n  toAddress: Address\n  capacity: Capacity\n  cells?: RawTransactionParams.Cell[]\n}\n\ninterface ComplexRawTransactionParams extends RawTransactionParams.Base {\n  fromAddresses: Address[]\n  receivePairs: { address: Address; capacity: Capacity; type?: CKBComponents.Script | null }[]\n  cells: Map<LockHash, RawTransactionParams.Cell[]>\n}\n\nexport class Branch {\n  public cells: Map<LockHash, RawTransactionParams.Cell[]> = new Map()\n\n  public rpc: BranchRPC\n\n  public utils = utils\n\n  private _node: CKBComponents.Node\n\n  public config: {\n    secp256k1Dep?: DepCellInfo\n    daoDep?: DepCellInfo\n  } = {}\n\n  constructor(nodeUrl: URL = 'http://localhost:8114') {\n    this._node = {\n      url: nodeUrl,\n    }\n    this.rpc = new BranchRPC(nodeUrl)\n  }\n\n  public setNode(node: URL | CKBComponents.Node): CKBComponents.Node {\n    if (typeof node === 'string') {\n      this._node.url = node\n    } else {\n      this._node = node\n    }\n\n    this.rpc.setNode(this._node)\n\n    return this._node\n  }\n\n  public get node(): CKBComponents.Node {\n    return this._node\n  }\n\n  public generateLockHash = (\n    args: string,\n    dep: Omit<CKBComponents.Script, 'args'> | undefined = this.config.secp256k1Dep,\n  ) => {\n    if (!dep) {\n      throw new ParameterRequiredException('deps')\n    }\n\n    return this.utils.scriptToHash({ ...dep, args })\n  }\n\n  public loadDeps = async () => {\n    const genesisBlock = await this.rpc.getBlockByNumber('0x0')\n    if (!genesisBlock) {\n      throw new Error('Fail to load the genesis block')\n    }\n    this.#setDaoDep(genesisBlock)\n    this.#setSecp256k1Dep(genesisBlock)\n    return this.config\n  }\n\n  /**\n   * @memberof Core\n   * @description The method used to load cells from lumos indexer as shown in the tutorial\n   * @tutorial https://github.com/ckb-js/ckb-sdk-js/blob/develop/packages/ckb-sdk-core/examples/sendTransactionWithLumosCollector.js\n   */\n  public loadCells = async (\n    params: LoadCellsParams.FromIndexer & {\n      save?: boolean\n    },\n  ) => {\n    const lockHash = this.utils.scriptToHash(params.lock)\n    const cells = await loadCellsFromIndexer(params)\n    if (params.save) {\n      this.cells.set(lockHash, cells)\n    }\n    return cells\n  }\n\n  public signWitnesses = signWitnesses\n\n  public signTransaction =\n    (key: Key | Map<LockHash, Key>) =>\n    (\n      transaction: CKBComponents.RawTransactionToSign,\n      cells: Array<{ outPoint: CKBComponents.OutPoint; lock: CKBComponents.Script }> = [],\n    ) => {\n      if (!key) throw new ParameterRequiredException('Private key or address object')\n      this.#validateTransactionToSign(transaction)\n\n      const transactionHash = this.utils.rawTransactionToHash(transaction)\n      const inputCells = isMap(key) ? filterCellsByInputs(cells, transaction.inputs) : undefined\n\n      const signedWitnesses = this.signWitnesses(key)({\n        transactionHash,\n        witnesses: transaction.witnesses,\n        inputCells,\n      })\n      return {\n        ...transaction,\n        witnesses: signedWitnesses.map(witness =>\n          typeof witness === 'string' ? witness : this.utils.serializeWitnessArgs(witness),\n        ),\n      }\n    }\n\n  /**\n   * @description Generate a raw transaction object to sign\n   * @param {object} txObject, 1-1 tx or m-n tx\n   * @returns rawTxToSign\n   * @example 1-1 tx\n   *```\n   *          {\n   *            fromAddress:          Address, specify the address of inputs\n   *            toAddress:            Address, specify the address included in outputs\n   *            capacity:             Capacity, specify the value to transfer in this tx\n   *\n   *            cells?:               Array<RawTransactionParams.Cell>, provide\n   *                                  live cells to generate input cells in this tx\n   *\n   *            fee?:                 Fee, specify the fee or fee reconciler\n   *                                  along with this tx, fee reconciler allows\n   *                                  fee calculation on the fly\n   *\n   *            safeMode:             boolean, specify whether to skip cell\n   *                                  containing data or type script or not,\n   *                                  default to be true\n   *\n   *            deps:                 DepCellInfo | Array<DepCellInfo>\n   *                                  specify deps included in this tx, filling\n   *                                  in the `cellDeps` field of a raw tx\n   *\n   *            capacityThreshold?:   Capacity, specify the minimal capacity of\n   *                                  each outputs, default to be 6_100_000_000\n   *                                  shannon(61 CKB) for a bare cell\n   *\n   *            changeThreshold?:     Capacity, specify the minimal capacity of\n   *                                  the change cell, default to be 6_100_000_000\n   *                                  shannon(61 CKB) for a bare cell, useful on\n   *                                  sending a tx without change by setting it 0\n   *\n   *            changeLockScript?:    CKBComponents.Script, specify the change\n   *                                  receiver of this tx, default to be the owner\n   *                                  of the first input\n   *\n   *            witnesses?:           Array<CKBComponents.WitnessArgs | CKBComponents.Witness>\n   *                                  specify the witness list of this tx\n   *\n   *            outputsData?:         Array<string>, specify the output data list\n   *                                  of this tx\n   *          }\n   * ```\n   * @example m-n tx\n   * ```\n   *          {\n   *            fromAddresses:        Address[], specify the address of inputs\n   *\n   *            receivePairs:         Array<{\n   *                                    address: Address;\n   *                                    capacity: Capacity;\n   *                                    type?: CKBComponents.Script | null\n   *                                  }>\n   *                                  specify address, capacity and type lock\n   *                                  of outputs\n   *\n   *            cells:                Map<LockHash, RawTransactionParams.Cell[]>\n   *                                  provide live cells to generate input cells\n   *                                  in this tx\n   *\n   *            fee?:                 same as that in 1-1 tx\n   *            safeMode:             same as that in 1-1 tx\n   *            deps:                 same as that in 1-1 tx\n   *            capacityThreshold?:   same as that in 1-1 tx\n   *            changeThreshold?:     same as that in 1-1 tx\n   *            changeLockScript?:    same as that in 1-1 tx\n   *            witnesses?:           same as that in 1-1 tx\n   *            outputsData?:         same as that in 1-1 tx\n   *          }\n   * ```\n   */\n  public generateRawTransaction = ({\n    fee,\n    safeMode = true,\n    deps,\n    capacityThreshold,\n    changeThreshold,\n    witnesses,\n    outputsData,\n    ...params\n  }: SimpleRawTransactionParams | ComplexRawTransactionParams) => {\n    if (this.#isSimpleTransaction(params)) {\n      const inputScript = this.utils.addressToScript(params.fromAddress)\n      const outputScript = this.utils.addressToScript(params.toAddress)\n\n      let availableCells = params.cells || []\n      if (!availableCells.length) {\n        availableCells = this.cells.get(this.utils.scriptToHash(inputScript)) ?? availableCells\n      }\n      return generateRawTransaction({\n        inputScript,\n        outputScript,\n        capacity: params.capacity,\n        fee,\n        safeMode,\n        cells: availableCells,\n        deps,\n        capacityThreshold,\n        changeThreshold,\n        witnesses,\n        outputsData,\n      })\n    }\n\n    if (this.#isComplexTransaction(params)) {\n      const inputScripts = params.fromAddresses.map(this.utils.addressToScript)\n      const outputs = params.receivePairs.map(pair => ({\n        lock: this.utils.addressToScript(pair.address),\n        capacity: pair.capacity,\n        type: pair.type,\n      }))\n\n      return generateRawTransaction({\n        inputScripts,\n        outputs,\n        cells: params.cells || this.cells,\n        fee,\n        safeMode,\n        deps,\n        capacityThreshold,\n        changeThreshold,\n        witnesses,\n        outputsData,\n      })\n    }\n    throw new Error('Parameters of generateRawTransaction are invalid')\n  }\n\n  /**\n   * @memberof Core\n   * @description Generate a transaction to deposit capacity\n   * @tutorial https://github.com/nervosnetwork/rfcs/blob/master/rfcs/0023-dao-deposit-withdraw/0023-dao-deposit-withdraw.md#deposit\n   */\n  public generateDaoDepositTransaction = ({\n    fromAddress,\n    capacity,\n    fee,\n    cells = [],\n  }: {\n    fromAddress: Address\n    capacity: Capacity\n    fee: Capacity\n    cells?: RawTransactionParams.Cell[]\n  }) => {\n    this.#secp256k1DepsShouldBeReady()\n    this.#DAODepsShouldBeReady()\n\n    const rawTx = this.generateRawTransaction({\n      fromAddress,\n      toAddress: fromAddress,\n      capacity,\n      fee,\n      safeMode: true,\n      cells,\n      deps: [this.config.secp256k1Dep!, this.config.daoDep!],\n    })\n\n    rawTx.outputs[0].type = {\n      codeHash: this.config.daoDep!.typeHash!,\n      args: '0x',\n      hashType: this.config.daoDep!.hashType,\n    }\n\n    rawTx.outputsData[0] = '0x0000000000000000'\n\n    return rawTx\n  }\n\n  /**\n   * @memberof Core\n   * @description Generate a transaction to start a withdraw\n   * @tutorial https://github.com/nervosnetwork/rfcs/blob/master/rfcs/0023-dao-deposit-withdraw/0023-dao-deposit-withdraw.md#withdraw-phase-1\n   */\n  public generateDaoWithdrawStartTransaction = async ({\n    outPoint,\n    fee,\n    cells = [],\n  }: {\n    outPoint: CKBComponents.OutPoint\n    fee: Capacity\n    cells?: RawTransactionParams.Cell[]\n  }) => {\n    this.#secp256k1DepsShouldBeReady()\n    this.#DAODepsShouldBeReady()\n\n    const cellStatus = await this.rpc.getLiveCell(outPoint, false)\n    if (cellStatus.status !== 'live') throw new Error('Cell is not live yet.')\n\n    const tx = await this.rpc.getTransaction(outPoint.txHash)\n    if (tx.txStatus.status !== 'committed') throw new Error('Transaction is not committed yet')\n\n    const depositBlockHeader = await this.rpc.getBlock(tx.txStatus.blockHash).then(b => b.header)\n    const encodedBlockNumber = this.utils.toUint64Le(depositBlockHeader.number)\n\n    const fromAddress = this.utils.bech32Address(cellStatus.cell.output.lock.args)\n\n    const rawTx = this.generateRawTransaction({\n      fromAddress,\n      toAddress: fromAddress,\n      capacity: '0x0',\n      fee,\n      safeMode: true,\n      deps: [this.config.secp256k1Dep!, this.config.daoDep!],\n      capacityThreshold: '0x0',\n      cells,\n    })\n\n    rawTx.outputs[0] = tx.transaction.outputs[+outPoint.index]\n    rawTx.outputsData[0] = encodedBlockNumber\n\n    rawTx.inputs.unshift({ previousOutput: outPoint, since: '0x0' })\n    rawTx.headerDeps.push(depositBlockHeader.hash)\n    return rawTx\n  }\n\n  /**\n   * @memberof Core\n   * @description Generate a transaction to finish a withdraw\n   * @tutorial https://github.com/nervosnetwork/rfcs/blob/master/rfcs/0023-dao-deposit-withdraw/0023-dao-deposit-withdraw.md#withdraw-phase-2\n   */\n  public generateDaoWithdrawTransaction = async ({\n    depositOutPoint,\n    withdrawOutPoint,\n    fee,\n  }: {\n    depositOutPoint: CKBComponents.OutPoint\n    withdrawOutPoint: CKBComponents.OutPoint\n    fee: Capacity\n  }): Promise<CKBComponents.RawTransactionToSign> => {\n    this.#secp256k1DepsShouldBeReady()\n    this.#DAODepsShouldBeReady()\n    const { JSBI } = this.utils\n\n    const cellStatus = await this.rpc.getLiveCell(withdrawOutPoint, true)\n    if (cellStatus.status !== 'live') throw new Error('Cell is not live yet')\n\n    const tx = await this.rpc.getTransaction(withdrawOutPoint.txHash)\n    if (tx.txStatus.status !== 'committed') throw new Error('Transaction is not committed yet')\n\n    const depositBlockNumber = this.utils.bytesToHex(\n      this.utils.hexToBytes(cellStatus.cell.data?.content ?? '').reverse(),\n    )\n\n    const depositBlockHeader = await this.rpc.getBlockByNumber(BigInt(depositBlockNumber)).then(block => block.header)\n    const withdrawStartBlockHeader = await this.rpc.getBlock(tx.txStatus.blockHash).then(block => block.header)\n\n    const withdrawEndEpoch = this.utils.getWithdrawEpoch(depositBlockHeader.epoch, withdrawStartBlockHeader.epoch)\n    const outputCapacity = await this.rpc.calculateDaoMaximumWithdraw(depositOutPoint, withdrawStartBlockHeader.hash)\n    const targetCapacity = JSBI.BigInt(outputCapacity)\n    const targetFee = JSBI.BigInt(`${fee}`)\n    if (JSBI.lessThan(targetCapacity, targetFee)) {\n      throw new Error(`The fee(${targetFee}) is too big that withdraw(${targetCapacity}) is not enough`)\n    }\n\n    const outputs: CKBComponents.CellOutput[] = [\n      {\n        capacity: `0x${JSBI.subtract(targetCapacity, targetFee).toString(16)}`,\n        lock: tx.transaction.outputs[+withdrawOutPoint.index].lock,\n      },\n    ]\n\n    const outputsData = ['0x']\n\n    return {\n      version: '0x0',\n      cellDeps: [\n        { outPoint: this.config.secp256k1Dep!.outPoint, depType: this.config.secp256k1Dep!.depType },\n        { outPoint: this.config.daoDep!.outPoint, depType: this.config.daoDep!.depType },\n      ],\n      headerDeps: [depositBlockHeader.hash, withdrawStartBlockHeader.hash],\n      inputs: [\n        {\n          previousOutput: withdrawOutPoint,\n          since: withdrawEndEpoch,\n        },\n      ],\n      outputs,\n      outputsData,\n      witnesses: [\n        {\n          lock: '',\n          inputType: '0x0000000000000000',\n          outputType: '',\n        },\n      ],\n    }\n  }\n\n  public calculateDaoMaximumWithdraw = async (\n    depositOutPoint: CKBComponents.OutPoint,\n    withdraw: CKBComponents.Hash | CKBComponents.OutPoint,\n  ): Promise<string> => {\n    let tx = await this.rpc.getTransaction(depositOutPoint.txHash)\n    if (tx.txStatus.status !== 'committed') throw new Error('Transaction is not committed yet')\n    const depositBlockHash = tx.txStatus.blockHash\n    let cellOutput = tx.transaction.outputs[+depositOutPoint.index]\n    let cellOutputData = tx.transaction.outputsData[+depositOutPoint.index]\n    let withdrawBlockHash: CKBComponents.Hash\n    if (typeof withdraw === 'string') {\n      withdrawBlockHash = withdraw\n    } else {\n      tx = await this.rpc.getTransaction(withdraw.txHash)\n      if (tx.txStatus.status !== 'committed') throw new Error('Transaction is not committed yet')\n      withdrawBlockHash = tx.txStatus.blockHash\n      cellOutput = tx.transaction.outputs[+withdraw.index]\n      cellOutputData = tx.transaction.outputsData[+withdraw.index]\n    }\n    const [depositHeader, withDrawHeader] = await Promise.all([\n      this.rpc.getHeader(depositBlockHash),\n      this.rpc.getHeader(withdrawBlockHash),\n    ])\n    return utils.calculateMaximumWithdraw(cellOutput!, cellOutputData!, depositHeader.dao, withDrawHeader.dao)\n  }\n\n  #secp256k1DepsShouldBeReady = () => {\n    if (!this.config.secp256k1Dep) {\n      throw new ParameterRequiredException('Secp256k1 dep')\n    }\n  }\n\n  #DAODepsShouldBeReady = () => {\n    if (!this.config.daoDep) {\n      throw new ParameterRequiredException('Dao dep')\n    }\n  }\n\n  #validateTransactionToSign = (transaction: CKBComponents.RawTransactionToSign) => {\n    if (!transaction) throw new ParameterRequiredException('Transaction')\n    if (!transaction.witnesses) throw new ParameterRequiredException('Witnesses')\n    if (!transaction.outputsData) throw new ParameterRequiredException('OutputsData')\n    if (transaction.outputsData.length < transaction.outputs.length) throw new Error('Invalid count of outputsData')\n  }\n\n  #isSimpleTransaction = (params: any): params is SimpleRawTransactionParams => {\n    return 'fromAddress' in params && 'toAddress' in params\n  }\n\n  #isComplexTransaction = (params: any): params is ComplexRawTransactionParams => {\n    return 'fromAddresses' in params && 'receivePairs' in params\n  }\n\n  #setSecp256k1Dep = async (genesisBlock: CKBComponents.Block) => {\n    const secp256k1DepTxHash = genesisBlock?.transactions[1].hash\n    const typeScript = genesisBlock?.transactions[0]?.outputs[1]?.type!\n\n    const secp256k1TypeHash = this.utils.scriptToHash(typeScript)\n\n    this.config.secp256k1Dep = {\n      hashType: 'type',\n      codeHash: secp256k1TypeHash,\n      outPoint: {\n        txHash: secp256k1DepTxHash,\n        index: '0x0',\n      },\n      depType: 'depGroup',\n    }\n  }\n\n  #setDaoDep = (genesisBlock: CKBComponents.Block) => {\n    const daoDepTxHash = genesisBlock?.transactions[0].hash\n    const typeScript = genesisBlock?.transactions[0]?.outputs[2]?.type!\n    const data = genesisBlock?.transactions[0]?.outputsData[2]\n\n    const typeHash = this.utils.scriptToHash(typeScript)\n\n    const s = utils.blake2b(32, null, null, utils.PERSONAL)\n    s.update(utils.hexToBytes(data!))\n    const codeHash = `0x${s.digest('hex')}`\n\n    this.config.daoDep = {\n      hashType: 'type',\n      codeHash,\n      typeHash,\n      outPoint: {\n        txHash: daoDepTxHash,\n        index: '0x2',\n      },\n      depType: 'code',\n    }\n  }\n}\n\n","/**\n * @see https://github.com/nervosnetwork/ckb/blob/develop/protocol/src/protocol.fbs for more information\n */\n\nexport namespace CKBComponents {\n  export type DAO = string\n  export type Hash = string\n  export type Number = string\n  export type Hash256 = string\n  export type UInt32 = number\n  export type Index = string\n  export type Version = string\n  export type Count = string\n  export type Difficulty = string\n  export type BlockNumber = string\n  export type EpochInHeader = string\n  export type Capacity = string\n  export type ProposalShortId = string\n  export type Timestamp = string\n  export type Nonce = string\n  export type Cycles = string\n  export type Size = string\n  export type OutputsValidator = 'default' | 'passthrough' | undefined\n  export type RationalU256 = Record<'denom' | 'numer', string>\n  export type ProposalWindow = Record<'closest' | 'farthest', BlockNumber>\n  export type EpochNumberWithFraction = string\n  export enum TransactionStatus {\n    Pending = 'pending',\n    Proposed = 'proposed',\n    Committed = 'committed',\n  }\n\n  export type ScriptHashType = 'data' | 'type' | 'data1' | 'data2'\n\n  export type DepType = 'code' | 'depGroup'\n  export type JsonBytes = string\n\n  /**\n   * @typedef Bytes, keep consistent with CKB\n   * @description Bytes will be serialized to string\n   * @see https://github.com/nervosnetwork/ckb/blob/develop/util/jsonrpc-types/src/blockchain.rs#L19\n   */\n  export type Bytes = string\n  export type Since = string\n  export interface Node {\n    url: string\n    httpAgent?: any\n    httpsAgent?: any\n  }\n  export interface Method {\n    name: string\n    method: string\n    paramsFormatters: Function[]\n    resultFormatters?: Function\n  }\n  /**\n   * RPC Units\n   */\n\n  /* eslint-disable max-len */\n  /**\n   * @typedef Script, lock or type script\n   * @description Script, the script model in CKB. CKB scripts use UNIX standard execution environment.\n   *              Each script binary should contain a main function with the following signature `int main(int argc, char* argv[]);`.\n   *              CKB will concat  `args`, then use the concatenated array to fill `argc/argv` part, then start the script execution.\n   *              Upon termination, the executed `main` function here will provide a return code,\n   *              `0` means the script execution succeeds, other values mean the execution fails.\n   * @property args, arguments.\n   * @property codeHash, point to its dependency, if the referred dependency is listed in the deps field in a transaction,\n   *                     the codeHash means the hash of the referred cell's data.\n   * @property hashType, a enumerate indicates the type of the code which is referened by the code hash\n   */\n  /* eslint-enable max-len */\n  export interface Script {\n    args: Bytes\n    codeHash: Hash256\n    hashType: ScriptHashType\n  }\n\n  /**\n   * @typedef CellInput, cell input in a transaction\n   * @property previousOutput, point to its P1 cell\n   * @property since, a parameter to prevent a cell to be spent before a centain block timestamp or a block number,\n   *           [RFC](https://github.com/nervosnetwork/rfcs/blob/master/rfcs/0017-tx-valid-since/0017-tx-valid-since.md)\n   */\n  export interface CellInput {\n    previousOutput: OutPoint | null\n    since: Since\n  }\n\n  /**\n   * @typedef CellOutput, cell output in a transaction\n   * @property capacity, the capacity of the genereated P1 cell\n   * @property lock, lock script\n   * @property type, type script\n   */\n  export interface CellOutput {\n    capacity: Capacity\n    lock: Script\n    type?: Script | null\n  }\n\n  /**\n   * @typedef OutPoint, used to refer a generated cell by transaction hash and output index\n   * @property hash, transaction hash\n   * @property index, index of cell output\n   */\n  export interface OutPoint {\n    txHash: Hash256\n    index: Index\n  }\n\n  /**\n   * @typeof CellDep, cell dependencies in a transaction\n   * @property outPoint, the out point of the cell dependency\n   * @property depType, indicate if the data of the cell containing a group of dependencies\n   */\n  export interface CellDep {\n    outPoint: OutPoint | null\n    depType: DepType\n  }\n\n  export type Witness = Bytes\n\n  /**\n   * @typedef RawTransaction, raw transaction object\n   * @property version, transaction version\n   * @property cellDeps, cell deps used in the transaction\n   * @property headerDeps, header deps referenced to a specific block used in the transaction\n   * @property inputs, cell inputs in the transaction\n   * @property outputs, cell outputs in the transaction\n   * @property witnesses, segrated witnesses\n   * @property outputsData, data referenced by scripts\n   */\n  export interface RawTransaction {\n    version: Version\n    cellDeps: CellDep[]\n    headerDeps: Hash256[]\n    inputs: CellInput[]\n    outputs: CellOutput[]\n    witnesses: Witness[]\n    outputsData: Bytes[]\n  }\n\n  /**\n   * @typedef Transaction, transaction object\n   * @extends RawTransaction\n   * @property hash, transaction hash\n   */\n  export interface Transaction extends RawTransaction {\n    hash: Hash256\n  }\n\n  export interface TransactionWithStatus {\n    transaction: Transaction\n    txStatus:\n      | {\n          blockHash: Hash256\n          status: TransactionStatus.Committed\n        }\n      | {\n          blockHash: null\n          status: TransactionStatus.Pending | TransactionStatus.Proposed\n        }\n  }\n\n  /**\n   * @typeof TransactionPoint\n   * @property blockNumber\n   * @property index\n   * @property txHash\n   */\n  export interface TransactionPoint {\n    blockNumber: BlockNumber\n    index: Index\n    txHash: Hash256\n  }\n\n  /**\n   * @TransactionByLockHash\n   * @property consumedBy\n   * @property createdBy\n   */\n  export interface TransactionByLockHash {\n    consumedBy: null | TransactionPoint\n    createdBy: TransactionPoint\n  }\n\n  export type TransactionsByLockHash = TransactionByLockHash[]\n\n  /**\n   * @typedef BlockHeader, header of a block\n   * @property compactTarget\n   * @property dao\n   * @property epoch\n   * @property hash\n   * @property number\n   * @property parentHash\n   * @property proposalsHash\n   * @property nonce\n   * @property timestamp\n   * @property transactionsRoot\n   * @property extraHash\n   * @property version\n   */\n  export interface BlockHeader {\n    compactTarget: Hash\n    dao: DAO\n    epoch: EpochInHeader\n    hash: Hash256\n    number: BlockNumber\n    parentHash: Hash256\n    proposalsHash: Hash256\n    nonce: Nonce\n    timestamp: Timestamp\n    transactionsRoot: Hash256\n    extraHash: Hash256\n    version: Version\n  }\n\n  /**\n   * @typedef UncleBlock, uncle block object\n   * @property header, block header\n   * @property proposals\n   */\n\n  export interface UncleBlock {\n    header: BlockHeader\n    proposals: ProposalShortId[]\n  }\n\n  /**\n   * @typedef Block, block object\n   * @property header, block header\n   * @property uncles, uncle blocks\n   * @property transactions\n   * @property proposals\n   * @property extension\n   */\n  export interface Block {\n    header: BlockHeader\n    uncles: UncleBlock[]\n    transactions: Transaction[]\n    proposals: ProposalShortId[]\n    extension?: JsonBytes | null\n  }\n\n  /**\n   * @typedef Cell, cell object\n   * @property capacty, cell capacity\n   * @property lock, lock hash\n   */\n  export interface Cell extends CellOutput {}\n\n  /**\n   * @typeof Live Cell\n   * @property data, the data and data hash of the live cell\n   * @property output, the previous cell the live cell derives from\n   */\n\n  export interface LiveCell {\n    data?: {\n      content: Hash\n      hash: Hash256\n    }\n    output: CellOutput\n  }\n\n  /**\n   * @typedef Cell, cell object\n   * @property capacty, cell capacity\n   * @property lock, lock hash\n   * @property outPoint\n   */\n\n  export interface CellIncludingOutPoint {\n    blockHash: Hash256\n    capacity: Capacity\n    lock: Script\n    outPoint: OutPoint | null\n    cellbase: boolean\n    outputDataLen: string\n  }\n\n  export type TransactionTrace = { action: string; info: string; time: Timestamp }[]\n\n  export enum CellStatus {\n    Live = 'live',\n    Unknown = 'unknown',\n  }\n\n  export interface LiveCellByLockHash {\n    cellOutput: CellOutput\n    createdBy: TransactionPoint\n    cellbase: boolean\n    outputDataLen: string\n  }\n\n  export type LiveCellsByLockHash = LiveCellByLockHash[]\n\n  export interface AlertMessage {\n    id: string\n    priority: string\n    noticeUntil: Timestamp\n    message: string\n  }\n\n  export interface BlockchainInfo {\n    isInitialBlockDownload: boolean\n    epoch: string\n    difficulty: string\n    medianTime: string\n    chain: string\n    alerts: AlertMessage[]\n  }\n\n  export interface LocalNodeInfo {\n    active: boolean\n    addresses: Record<'address' | 'score', string>[]\n    connections: string\n    nodeId: string\n    protocols: { id: string; name: string; supportVersions: string[] }[]\n    version: string\n  }\n\n  export interface RemoteNodeInfo {\n    addresses: Record<'address' | 'score', string>[]\n    connectedDuration: string\n    isOutbound: boolean\n    lastPingDuration: string\n    nodeId: string\n    protocols: Record<'id' | 'version', string>[]\n    syncState: Record<\n      | 'bestKnownHeaderHash'\n      | 'bestKnownHeaderNumber'\n      | 'canFetchCount'\n      | 'inflightCount'\n      | 'lastCommonHeaderHash'\n      | 'lastCommonHeaderNumber'\n      | 'unknownHeaderListSize',\n      string | null\n    >\n    version: string\n  }\n\n  export interface PeersState {\n    lastUpdated: string\n    blocksInFlight: string\n    peer: string\n  }\n\n  export interface TxPoolInfo {\n    lastTxsUpdatedAt: Timestamp\n    minFeeRate: string\n    orphan: Count\n    pending: Count\n    proposed: Count\n    tipHash: Hash256\n    tipNumber: BlockNumber\n    totalTxCycles: Cycles\n    totalTxSize: Size\n  }\n\n  export enum CapacityUnit {\n    Shannon = 1,\n    Byte = 100000000,\n  }\n\n  export interface Epoch {\n    compactTarget: Hash\n    length: String\n    number: String\n    startNumber: String\n  }\n\n  export interface RunDryResult {\n    cycles: Cycles\n  }\n\n  export interface LockHashIndexState {\n    blockHash: Hash256\n    blockNumber: BlockNumber\n    lockHash: Hash256\n  }\n\n  export type LockHashIndexStates = LockHashIndexState[]\n\n  export interface BannedAddress {\n    address: string\n    banReason: string\n    banUntil: Timestamp\n    createdAt: Timestamp\n  }\n\n  export type BannedAddresses = BannedAddress[]\n\n  export interface CellbaseOutputCapacityDetails {\n    primary: string\n    proposalReward: string\n    secondary: string\n    total: string\n    txFee: string\n  }\n\n  export interface FeeRate {\n    feeRate: string\n  }\n\n  export type BytesOpt = Bytes | undefined\n\n  export interface WitnessArgs {\n    lock: BytesOpt // witness for lock script in input\n    inputType: BytesOpt // witness for type script in input\n    outputType: BytesOpt // witness for type script in output\n  }\n\n  export interface RawTransactionToSign extends Omit<RawTransaction, 'witnesses'> {\n    witnesses: (WitnessArgs | Witness)[]\n  }\n\n  export interface CapacityByLockHash {\n    blockNumber: BlockNumber\n    capacity: Capacity\n    cellsCount: string\n  }\n\n  export interface BlockEconomicState {\n    finalizedAt: string\n    issuance: {\n      primary: string\n      secondary: string\n    }\n    minerReward: {\n      committed: string\n      primary: string\n      proposal: string\n      secondary: string\n    }\n    txsFee: string\n  }\n\n  export interface SyncState {\n    bestKnownBlockNumber: string\n    bestKnownBlockTimestamp: string\n    fastTime: string\n    ibd: boolean\n    inflightBlocksCount: string\n    lowTime: string\n    normalTime: string\n    orphanBlocksCount: string\n  }\n\n  export interface TransactionProof {\n    blockHash: Hash\n    proof: {\n      indices: Number[]\n      lemmas: Hash[]\n    }\n    witnessesRoot: Hash\n  }\n\n  export type TxPoolIds = Record<'pending' | 'proposed', Array<Hash256>>\n\n  export interface TxVerbosity {\n    cycles: Cycles\n    size: Size\n    fee: Capacity\n    ancestorsSize: Size\n    ancestorsCycles: Cycles\n    ancestorsCount: Count\n  }\n\n  export type TxPoolVerbosity = Record<'pending' | 'proposed', Record<Hash256, TxVerbosity>>\n\n  export type RawTxPool = TxPoolIds | TxPoolVerbosity\n\n  export interface Consensus {\n    id: string\n    genesisHash: Hash256\n    hardforkFeatures: Array<{ rfc: string; epochNumber: string | null }>\n    daoTypeHash: Hash256 | null\n    secp256k1Blake160SighashAllTypeHash: Hash256 | null\n    secp256k1Blake160MultisigAllTypeHash: Hash256 | null\n    initialPrimaryEpochReward: Capacity\n    secondaryEpochReward: Capacity\n    maxUnclesNum: string\n    orphanRateTarget: RationalU256\n    epochDurationTarget: string\n    txProposalWindow: ProposalWindow\n    proposerRewardRatio: RationalU256\n    cellbaseMaturity: EpochNumberWithFraction\n    medianTimeBlockCount: Count\n    maxBlockCycles: Cycles\n    maxBlockBytes: string\n    blockVersion: Version\n    txVersion: Version\n    typeIdCodeHash: Hash256\n    maxBlockProposalsLimit: string\n    primaryEpochRewardHalvingInterval: string\n    permanentDifficultyInDummy: boolean\n  }\n\n  /**\n   * FeeRateStatistics\n   * mean: Uint64 - mean\n   * median: Uint64 - median\n   */\n  export type FeeRateStats = {\n    mean: string\n    median: string\n  }\n}\n"]}